Server & Infrastructure
=======================

1. SQL vs NOSQL:
	
	a. SQL databases represent data in form of tables which consists of n number of rows of data whereas NoSQL databases are the collection of key-value pair, documents, graph databases or wide-column stores which do not have standard schema definitions which it needs to adhered to.

	b. SQL databases have predefined schema whereas NoSQL databases have dynamic schema for unstructured data.

	c. In most typical situations, SQL databases are vertically scalable. You can manage increasing load by increasing the CPU, RAM, SSD, etc, on a single server. On the other hand, NoSQL databases are horizontally scalable. You can just add few more servers easily in your NoSQL database infrastructure to handle the large traffic.

	d. For complex queries: SQL databases are good fit for the complex query intensive environment whereas NoSQL databases are not good fit for complex queries. On a high-level, NoSQL don’t have standard interfaces to perform complex queries, and the queries themselves in NoSQL are not as powerful as SQL query language.

	e. SQL databases are not best fit for hierarchical data storage. But, NoSQL database fits better for the hierarchical data storage as it follows the key-value pair way of storing data similar to JSON data. NoSQL database are highly preferred for large data set (i.e for big data). Hbase is an example for this purpose.

	f. SQL databases are best fit for heavy duty transactional type applications, as it is more stable and promises the atomicity as well as integrity of the data. While you can use NoSQL for transactions purpose, it is still not comparable and sable enough in high load and for complex transactional applications.

	g. SQL databases emphasizes on ACID properties ( Atomicity, Consistency, Isolation and Durability) whereas the NoSQL database follows the Brewers CAP theorem ( Consistency, Availability and Partition tolerance )

2. Which Database Is Right For Your Business?
	
	MySQL is a strong choice for any business that will benefit from its pre-defined structure and set schemas. For example, applications that require multi-row transactions - like accounting systems or systems that monitor inventory - or that run on legacy systems will thrive with the MySQL structure.

	MongoDB, on the other hand, is a good choice for businesses that have rapid growth or databases with no clear schema definitions. More specifically, if you cannot define a schema for your database, if you find yourself denormalizing data schemas, or if your schema continues to change - as is often the case with mobile apps, real-time analytics, content management systems, etc.- MongoDB can be a strong choice for you.

	When strong consistency is not a problem, you can choose NoSQL. Note that NOSQL will obviously have eventual consistency.

3. Redis DB: It is consider as one of the fastest NoSQL server as it works with the in-memory dataset.

4. HTTP vs HTTPS:
	
	Hyper Text Transfer Protocol Secure (HTTPS) is the secure version of HTTP, the protocol over which data is sent between your browser and the website that you are connected to. The 'S' at the end of HTTPS stands for 'Secure'. It means all communications between your browser and the website are encrypted. HTTPS is often used to protect highly confidential online transactions like online banking and online shopping order forms.

	How does HTTPS work?
		HTTPS pages typically use one of two secure protocols to encrypt communications - SSL (Secure Sockets Layer) or TLS (Transport Layer Security). Both the TLS and SSL protocols use what is known as an 'asymmetric' Public Key Infrastructure (PKI) system. An asymmetric system uses two 'keys' to encrypt communications, a 'public' key and a 'private' key. Anything encrypted with the public key can only be decrypted by the private key and vice-versa.

		As the names suggest, the 'private' key should be kept strictly protected and should only be accessible the owner of the private key. In the case of a website, the private key remains securely ensconced on the web server. Conversely, the public key is intended to be distributed to anybody and everybody that needs to be able to decrypt information that was encrypted with the private key.

	What is a HTTPS certificate?
		When you request a HTTPS connection to a webpage, the website will initially send its SSL certificate to your browser. This certificate contains the public key needed to begin the secure session. Based on this initial exchange, your browser and the website then initiate the 'SSL handshake'. The SSL handshake involves the generation of shared secrets to establish a uniquely secure connection between yourself and the website.

		When a trusted SSL Digital Certificate is used during a HTTPS connection, users will see a padlock icon in the browser address bar. When an Extended Validation Certificate is installed on a web site, the address bar will turn green.

	Why is a SSL certificate required?
		All communications sent over regular HTTP connections are in 'plain text' and can be read by any hacker that manages to break into the connection between your browser and the website. This presents a clear danger if the 'communication' is on an order form and includes your credit card details or social security number. With a HTTPS connection, all communications are securely encrypted. This means that even if somebody managed to break into the connection, they would not be able decrypt any of the data which passes between you and the website.

5. What is reverse proxy?
		The server that retrieves resources on behalf of a client from one or more servers. These resources are then returned to the client appearing as if they originated from the proxy server itself.

6. What is the difference between Web Server/HTTP Server and Application Server?
	Application Server is sometimes mixed up with web server while a web server handles mainly HTTP protocol and the application server deals with several different protocols including, but not limited to HTTP.
	In case of AutoMeta, nginx is the webserver and thin is the application server. nginx will take the HTTP request and then give it to the application server for processing where the complete business logic will be implemented and the result is displayed on the browser. Application server can also handle HTTP protocols directly without the need of nginx. The benefit of nginx is that it will redirect my request to different application server instances (:4000, :4001, ....). If application server had to handle this, then the users would have to type the ports of the application server instances directly: www.xyz.com:4008

6. What is NGINX?
	NGINX is a HTTP server (web server), reverse proxy, caching, load balancing, media streaming and more. The default port for nginx is 80. Apache is another web server.

6. What is HAProxy?
	High Availability Proxy provides a high available load balancer and proxy server for TCP/HTTP based application. It is written in C and has a reputation for being fast and efficient in terms of processor and memory usage. Default port is 8100.

7. What is SSL?
	Secure Socket Layer which is a standard security protocol for establishing encrypted links between a web server and a browser in an online communication.

	The browser/server checks to see whether or not it trusts the SSL certificate and it if does, it sends a message to the browser. The web browser sends back a digitally signed acknowledgement to start an SSL encrypted session. Encrypted data is shared between browser and the web server.

8. RabbitMQ
	This is a messaging queue mechanism where there can be multiple 'exchanges' and each exchange can have multiple queues. For each action in the controller, we have to create a new queue in one of the exchanges. We are using the exchange name as 'sneakers' in autometa. It has 7 queues in int for each of the seven actions which require background processing of jobs. Default port is 5672

9. Sneakers
	This is a background job executor gem in rails. The action which we want to execute in the background should have the exchange and queue configured Example: (queue: abc of exchange 'sneakers'). Now, we would have different files for each worker in the app/worker/ directory. Each file would say that I belong to the queue: "some queue name" and exchange: "some exchange". So, the file which would have written queue: "abc" and exchange: "sneakers" would be picked up and then the action "work" would be executed in the same file. 

10. Sharding
	Sharding is a type of database partitioning that separates very large databases into smaller, faster and more easily managed parts called data shards. 

		How it works?
			It creates a map table that contains information about the range of primary keys of different table in different shards. Whenever we get a query based on the ID in query, shard can be identified using the map table.

		It is of two types:
			a. Horizontal Sharding: When my DB table/collection is having a lot of rows or growing vertically, then we do Horizontal Sharding. 
				Pros:
					1. A new database can be added easily. Just make a new database and add the entry in the map table. That's it.
					2. Very obviously, the query becomes very fast. As the size of shard is small as compared to original DB.
				Cons:
					1. Aggregation queries like MAX, MIN, AVG, SUM are not supported. As we need to traverse to each of the shard to get the aggregated value.
			b. Vertical Sharding: When my DB table/collection is having a lot of columns out of which some columns are required very rarely, then I can shard them vertically to store them in a different database. Note that both the tables now would have the primary key. 
				Pros:
				  1. Aggregation queries are supported easily (Min, Max, Avg, Sum of a specific column)
				Cons:
				 	1. It becomes difficult to support a new query which requires columns from both the shards.
				 	2. Extra space is required to keep the primary key. 

11. Difference between Partitioning and Sharding
	The difference between Partitioning and Sharding is mostly semantic. With Partitioning, your tables will still be in the same database instance whereas with Sharding, your tables are split across multiple database servers.

12. Scaling
		Scaling of an application is termed as increasing the capacity to handle multiple request without compromising the availability of the application.
		It's of two types:
			a. Horizontal: Adding new components to the application.
				Pros: 
					1. Highly scalable. As new component can be added at any point of time. 
					2. New components can be added incrementally. No downtime required.
					3. Comparatively cheaper. 10 components of computation power x will be cheaper as compared to single component with 10x computation power.
					4. No single point of failure.
					5. We can serve request from all over the globe in good response time by keeping servers in different geographical locations.
				Cons:
					1. Synchronization b/w different components need to be handled carefully. 
					2. Communication delay or synchronization delay is there.
			b. Vertical: adding extra capability to existing components in the application.
				Pros: 
					1. We have only one component with very high computation. So there if no synchronization required.
					2. No communication delay.
				Cons:
					1. Very expensive.
					2. Single point of failure.
					3. Not so easy to scale. Migration is very difficult: Downtime is required.
					4. Since I only have one server, request coming far away around the globe would be slow.

13. Why did you choose MongoDB in AutoMeta and not MySQL or anything?

	We had to choose any two from Consistency, Availability and Partitioning (as per CAP theorem). 
	We chose: 
		1.Consistency: It is not something that is of utmost importance to us since it will obviously have eventual consistency. 
		2. Availability: we chose to have a highly available system. We need faster query time. Our data model is such that if we keep too much normalized form of data, it will need so many joins for most of the queries. So we it was a better solution to keep redundant data using MongoDB instead of keeping normalized data in SQL. In MongoDB we keep the copy of data wherever needed. 
		3. Partitioning: Mongo supports Sharding. So, this is a Yes.

14. Distributed System: A group of computers that work together to achieve some common goal. Lets say you have a website that runs a small service which converts doc to pdf. Gradually, as months passes, your website becomes popular and the server response become slower since it was not made to handle such huge amount of requests.

	a. What you can do now is upgrade your existing hardware, better RAM, better processor, etc. This is called Vertical Scaling but how long will you be able to do this?
	b. Instead of making your existing hardware better, buy more of similar hardware. So, instead of one machine's upgrade from 64Gb to 128GB, buy another 64GB RAM so that you have two 64GB RAMs. This is called Horizontal Scaling.

	When we do point b (Horizontal Scaling), then our task is divided across multiple servers. These servers/set of machines can together be called as Distributed Systems. So, whenever we talk about Distributed Systems, think of it as a system which is scaled horizontally.

15. Distributed Data Stores: We have two types of DBs till now. RDBMS and NoSQL. For both of them, we have different strategies on how to scale them.
	
	a. Master-Slave Strategy: We will have multiple database servers in which there will be one master and different slave database servers. Any write operation would happen in the master database. The read operations would happen from the slave databases. The synchronization between the slaves and master after master writes something new happens asynchronously. Since one may access data from slaves before this sync, the data in slaves for this delta time is inconsistent.
	b. Sharding


16. CAP Theorem: Consistency - Availability - Partitioning
		- Consistency: Database is consistent if at all point of time, it returns the correct value. In the master slave strategy, there is a moment when the master should sync with the slaves and for that time, the data in slaves is inconsistent. So, if a DB adopt this, then the data is inconsistent and can not be trusted all the time.
		- Availability: Even if some machine in my cluster goes down, the system should be available up and running.
		- Partitioning: If my connection between two machines goes down in a cluster, we should still be able to read and write data.

		In reality, one can't have all these three properties in the database. You can either have any of these two combinations. The database give us the configuration in our hands so that we can choose either of the two from these.

		NoSQL systems believe in A and P by sacrificing C. But remember that we won't have strict consistency but we will be eventual consistency here. Most of the applications can use this where the exact data is not important at all point of time. We have BASE property here meaning Basically Available and SoftState Eventual Consistency.

		IRCTC, Banking systems, etc where the data has to be correct at all point of time should use 'RDBMS' which ensures consistency over everything.

17. My website is slow. How should I proceed with this problem?
	- Schema
	- Hardware
	- Scaling
	- DB

Ruby and Rails
==============


Operating Systems
=================

1. Process vs Thread: 

		a. The typical difference is that threads (of the same process) run in a shared memory space, while processes run in separate memory spaces. 
		The benefits of this is: 
			* For tasks that involve sharing large amount of data, the fact that threads all share a process's memory pool, they do not have separate copies, that means that different threads can read and modify a shared pool of memory easily. While in case of processes data is shared through inter process communication (e.g., message passing mechanism) which significantly increases the number of system calls.
		The disadvantages of this is:
			* Synchronization overhead in case of thread: Shared data that is modified requires special handling in the form of locks and mutexes to prevent race conditions.
			* If something goes wrong in one thread and causes data corruption, the data is corrupted for all the threads in that process.

		b. Time required for creation and termination of process is more than a thread: To start a process, the whole process area must be duplicated for a new process copy to start, while in case of thread, very little memory coping is required(just the thread stack)

		c. Resource consumption is more in a process compared to a thread: A process operations are controlled with the help of PCB(Process control Block) can be considered as the brain of the process, which contains all the crucial information regarding to a process such as a process id, priority, state(ready, running, blocked and terminated), PWS and contents CPU register. For Threads, the kernel allocates a stack and a thread control block (TCB) which contains registers.

		d. Context switching in a process is faster in a thread than a process: The CPU caches and program context can be maintained between threads in a process while in case of processes it needs to be reloaded for switching a CPU to different processes.

		e. When a process is terminated uncertainly, it results in loss of process, while when a thread is terminated uncertainly, it can be reclaimed.


2. Virtual Memory:
	Virtual memory is a memory management capability of an operating system (OS) that uses hardware and software to allow a computer to compensate for physical memory shortages by temporarily transferring data from random access memory (RAM) to disk storage.

	Virtual memory was developed at a time when physical memory -- the installed RAM -- was expensive. Computers have a finite amount of RAM, so memory can run out, especially when multiple programs run at the same time. A system using virtual memory uses a section of the hard drive to emulate RAM. With virtual memory, a system can load larger programs or multiple programs running at the same time, allowing each one to operate as if it has infinite memory and without having to purchase more RAM.

	The use of virtual memory has its tradeoffs, particularly with speed. It's generally better to have as much physical memory as possible so programs work directly from RAM or physical memory. The use of virtual memory slows a computer because data must be mapped between virtual and physical memory, which requires extra hardware support for address translations.


3. Difference between virtual memory and swap memory:

	Virtual memory is a combination of RAM and disk space that running processes can use.
	Swap space is the portion of virtual memory that is on the hard disk, used when RAM is full.


Databases
=========


Object Oriented Programming / C++
=================================


General Programming / C
=======================

1. Memory Layout of a C program: https://www.geeksforgeeks.org/memory-layout-of-c-program/
	A typical memory representation of C program consists of following sections.
		
		a. Text segment: A text segment , also known as a code segment or simply as text, is one of the sections of a program in an object file or in memory, which contains executable instructions.
		
		b. Initialized data segment: Initialized data segment, usually called simply the Data Segment. A data segment is a portion of virtual address space of a program, which contains the global variables and static variables that are initialized by the programmer. Ex: static int i = 10 will be stored in data segment and global int i = 10 will also be stored in data segment
		
		c. Uninitialized data segment: Uninitialized data segment, often called the “bss” segment, named after an ancient assembler operator that stood for “block started by symbol.” Data in this segment is initialized by the kernel to arithmetic 0 before the program starts executing. For instance a variable declared static int i; would be contained in the BSS segment.
		
		d. Stack: Stack, where automatic variables are stored, along with information that is saved each time a function is called. Each time a function is called, the address of where to return to and certain information about the caller’s environment, such as some of the machine registers, are saved on the stack. The newly called function then allocates room on the stack for its automatic and temporary variables. This is how recursive functions in C can work. Each time a recursive function calls itself, a new stack frame is used, so one set of variables doesn’t interfere with the variables from another instance of the function.
		
		e. Heap: Heap is the segment where dynamic memory allocation usually takes place.
		The heap area begins at the end of the BSS segment and grows to larger addresses from there.The Heap area is managed by malloc, realloc, and free, which may use the brk and sbrk system calls to adjust its size


2. Direct Address Table:
		Direct Address Table is a data structure that has the capability of mapping records to their corresponding keys using arrays. In direct address tables, records are placed using their key values directly as indexes. They facilitate fast searching, insertion and deletion operations.

		We can understand the concept using the following example. We create an array of size equal to maximum value plus one (assuming 0 based index) and then use values as indexes. For example, in the following diagram key 21 is used directly as index.

		Advantages:
			- Searching in O(1) Time: 
				Direct address tables use arrays which are random access data structure, so, the key values (which are also the index of the array) can be easily used to search the records in O(1) time.
			- Insertion in O(1) Time: 
				We can easily insert an element in an array in O(1) time. The same thing follows in a direct address table also.
			- Deletion in O(1) Time: 
				Deletion of an element takes O(1) time in an array. Similarly, to delete an element in a direct address table we need O(1) time.
		
		Disadvantages:
			- Prior knowledge of maximum key value
			- Practically useful only if the maximum value is very less.
			- It causes wastage of memory space if there is a significant difference between total records and maximum value.
			- Hashing can overcome these limitations of direct address tables.

		Difference between Direct Address Table and Hashing:
			Hashing is an improvement over Direct Access Table. The only difference from hashing is, we do not use a hash function to find the index. We rather directly use values as indexes.

3. Hashing: 

		Hash Function:
			A function that converts a given big phone number to a small practical integer value. The mapped integer value is used as an index in hash table. In simple terms, a hash function maps a big number or string to a small integer that can be used as index in hash table.
			A good hash function should have following properties:
				1) Efficiently computable.
				2) Should uniformly distribute the keys (Each table position equally likely for each key)

		Hash Table: 
			An array that stores pointers to records corresponding to a given phone number. 

		Collision Handling: 
			Since a hash function gets us a small number for a big key, there is possibility that two keys result in same value. The situation where a newly inserted key maps to an already occupied slot in hash table is called collision and must be handled using some collision handling technique. Following are the ways to handle collisions:

			- Separate Chaining:
				The idea is to make each cell of hash table point to a linked list of records that have same hash function value. Chaining is simple, but requires additional memory outside the table.
					Advantages:
						1) Simple to implement.
						2) Hash table never fills up, we can always add more elements to chain.
						3) Less sensitive to the hash function or load factors.
						4) It is mostly used when it is unknown how many and how frequently keys may be inserted or deleted.
					Disadvantages:
						1) Cache performance of chaining is not good as keys are stored using linked list. Open addressing provides better cache performance as everything is stored in same table.
						2) Wastage of Space (Some Parts of hash table are never used)
						3) If the chain becomes long, then search time can become O(n) in worst case.
						4) Uses extra space for links.

			
			- Open Addressing: 
				In open addressing, all elements are stored in the hash table itself. Each table entry contains either a record or NIL. When searching for an element, we one by one examine table slots until the desired element is found or it is clear that the element is not in the table.
				Read https://www.geeksforgeeks.org/hashing-set-3-open-addressing/ for more details. 

					Double hashing is a collision resolving technique in Open Addressed Hash tables. Double hashing uses the idea of applying a second hash function to key when a collision occurs.
					
	Applications of hashing here: https://www.geeksforgeeks.org/applications-of-hashing/

4. If we are using separate chaining and we have a linked list of records mapped to a cell in the hash table, then how do I figure out what is the value of the key I asked for? Ex: cat and dog both give 123 as the output from the has function. { cat=>1 , dog=> 2}. If I search for cat, how will I get 1?

	> In linked list we don't just save the value, but also save the key.  So, when we look for "cat" and the hashing function gives me "123", then in the linked list, I will search for a value whose key is "cat". Hashing helps here since the search space reduced to just the linked list attached with the address "123"


5. 


Design Patterns
===============



MISC
====

1. Why doesn't stack's pop() method return anything?
2. If indexing is faster, then why don't we index the whole table?
3. What is combined indexing?