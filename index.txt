INDEX
=====

1. Coin Changing 1: Number of ways to create a sum from infinite supplies of some numbers:	
	a. dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];

2. Level Order Traversal Normal/ZigZag:	BFS/Deque

3. Left/Right View of a Binary Tree: Inorder Traversal (VLR, VRL)
	a. ALGO:
		void helper(TreeNode* root, int currentLevel, int &maxLevel, vector<int>& res) {
	        if(root == NULL)
	            return;
	        if(currentLevel > maxLevel){
	            res.push_back(root->val);
	            maxLevel = currentLevel;
	        }
	        helper(root->right, currentLevel+1, maxLevel, res);
	        helper(root->left, currentLevel+1, maxLevel, res);
	    }
	    vector<int> rightSideView(TreeNode* root) {
	        int maxLevel = -1; vector<int> res;
	        helper(root, 0, maxLevel, res);
	        return res;
	    }

4. Lowest Common Ancestor of a Binary Tree:
	a. When both nodes always exists: Check for nodes, find left & right LCA, return root, left or right on basis of left and right LCA.
	b. When both nodes may not exist: Find left & right LCA, Check for nodes & increase count, return root, left or right on basis of left and right LCA.
	c. When the address of root node is not given: Traverse both nodes till root & start again from one another till they meet at LCA.

5. Trie: 
	a. Remember the TrieNode() and Trie() class.
	b. Always move to the current =current->children[index] and then do stuff.
	c. Don't forget accessing index like this: index = word[i]-'a';
	d. The first thing to do in a function is to take a current node.
	e. ALGO:
		#define ALPHABETSIZE 26
		class TrieNode {
		public: 
		    TrieNode* children[ALPHABETSIZE];
		    bool isEndOfWord;
		    TrieNode(){
		        for(int i=0; i<ALPHABETSIZE; i++)
		            this->children[i] = NULL;
		        this->isEndOfWord = false;
		    }
		};
		class Trie {
		public:
		    TrieNode* root;
		    Trie() {
		        root = new TrieNode();
		    }
		};


6. Connect Nodes at same Level: BFS

7. Longest Increasing Subsequence/Subarray: 
	a. Subsequence: 
		i. Go for i[0:n] and j[0:i] and keep calc LIS for every i. O(n2)
		ii. if(arr[j]<=arr[i]){
              L[i] = max(L[j]+1, L[i]);
            }
	b. Subarray: Simply keep iterating till increasing and cal length till it decreases where you start again. O(n)

8. Longest Common Subsequence/Subarray:
	a. Subsequence: If the letters are same then consider last letter's LCS +1 else consider max by ignoring i or j.
		i.  if s1[i]==s2[j], then 
		        LCS[i][j] = 1+LCS[i-1][j-1];
		    else 
		        LCS[i][j] = max( LCS[i-1][j], LCS[i][j-1])
    b. Subarray: If the letters are same, then consider last letter's LCS+1 else let it be 0
    	i. 	if(nums1[i-1] == nums2[j-1]){
                dp[i][j] = dp[i-1][j-1]+1;
                maxLen = max(maxLen, dp[i][j]);
            }

9. [OBSOLETE] Add two numbers in a Linked List: Calculate sum=x+y+carry and create nodes with sum%10 till both nodes become NULL. 
	Check for a final carry

10. Next Greater Element: Stack
	a. ALGO:
		void nextGreaterElement(vector <int> arr){
		    stack <int> s;
		    for(int i=0;i<arr.size();i++){
		        while(!s.empty() && arr[i]>s.top()){
		            cout<<s.top()<<"-->"<<arr[i]<<endl;
		            s.pop();
		        }
		        s.push(arr[i]);
		    }
		    while(!s.empty()){
		        cout<<s.top()<<"-->-1"<<endl;
		        s.pop();
		    }
		}

11. Mirror Tree: Recursion.
	a. Invert a Binary Tree:
		class Solution {
		public:
		    TreeNode* invertTree(TreeNode* root) {
		        if(root == NULL)
		            return NULL;
		        
		        TreeNode* right = invertTree(root->right);
		        TreeNode* left = invertTree(root->left);
		        
		        root->left = right;
		        root->right = left;
		        
		        return root;
		    }
		};

	b. Is Mirror Tree?
		bool isMirror(node *t1, node* t2){
		    if(t1 == NULL && t2 == NULL) return true;
		    if(t1 == NULL || t2 == NULL) return false;
		    return (t1->data == t2->data) && isMirror(t1->left, t2->right) && isMirror(t1->right, t2->left);
		}

	c. Is Flip Equivalent?
		class Solution {
		public:
			bool flipEquiv(TreeNode* root1, TreeNode* root2) {
			    if(root1 == NULL && root2 == NULL)
			        return true;
			    if(root1 == NULL || root2 == NULL)
			        return false;
			    return  (root1->val == root2->val) && 
			            ((flipEquiv(root1->left, root2->left) && flipEquiv(root1->right, root2->right) ) || // nodes are not mirror
			             (flipEquiv(root1->left, root2->right) && flipEquiv(root1->right, root2->left) ) ); // nodes are mirror
			}
		};

12. Connect N ropes with minimum cost: Priority Queue to select 2 minimum and insert their sum

13. Detect and remove loops from Linked List: Take slow, fast pointers and if they meet then there is a cycle.

14. Rearrange characters so no two adjacent characters are same: 
	Keep adding max freq char in ans and temporarily move it out of PQ adjusting its freq.

15. Largest Sum Subarray: Kadane's Algorithm (At each point, decide whether I am alone greater or with the older sum)
	a. ALGO:
		class Solution {
		public:
		    int maxSubArray(vector<int>& nums) {
		        int n = nums.size();
		        int currentMax = nums[0];
		        int maxSoFar = nums[0];
		        
		        for(int i=1;i<n;i++){
		            currentMax = max(nums[i], currentMax+nums[i]);
		            maxSoFar = max(maxSoFar, currentMax);
		        }
		        return maxSoFar;
		    }
		};

16. Search Element in a sorted matrix: Search from top-right / Binary Search in 2D(row=mid/n, col=mid%n)

17. Minimum Platforms required for Trains: Priority Queue

18. Wildcard Pattern Matching: DP (Similar to Longest Common Subsequence)
	a. if(text[j-1] == pattern[i-1] || pattern[i-1]=='?'){
            dp[i][j] = dp[i-1][j-1];
        }
        else if(pattern[i-1]=='*'){
            dp[i][j] = dp[i-1][j] || dp[i][j-1];
        }
        else{
            dp[i][j] = 0;
        }

19. Sort an array of 0s, 1s and 2s: Take pointers: 
	a. low=starting of 1s, mid=starting of UNKNOWNS, high=ending of UNKNOWNS
	b. Keep putting elements in correct place till mid<=high
	c. ALGO:
		int low = 0; int mid = 0; int high = n-1;
	    while(mid<=high){ 
	        if(arr[mid]==0){
	            swap(&arr[mid],&arr[low]);
	            low++;
	            mid++;
	        }
	        else if(arr[mid]==1){
	            mid++;
	        }
	        else{
	            swap(&arr[high],&arr[mid]);
	            high--;
	        }
	    }

20. Heap Sort: heapify() the array first and then keep putting the largest element in the end.

21. Coin Changing 2: Number of ways to create a sum from limited supplies of some numbers:	
	dp[i][j] = dp[i-1][j] || dp[i-1][j-coins[i-1]]; 

22. [DUPLICATE-4]: Lowest Common Ancestor of a Binary Tree with root node not given: Traverse both nodes till root & start again from one 
	another till they meet at LCA.

23. Lowest Common Ancestor of a BST: Check if one val is at left and one is at right, this is the LCA. Otherwise choose the side.
	a. ALGO:
		node* lowestCommonAncestorBST(node *root, node *n1, node *n2){
		    if (root==NULL)
		        return NULL;
		    if(root->data > n1->data && root->data > n2->data)
		        return lowestCommonAncestorBST(root->left, n1, n2);
		    else if(root->data < n1->data && root->data < n2->data)
		        return lowestCommonAncestorBST(root->right, n1, n2);
		    else
		        return root;
		}

24. Kth largest integer in a stream of Integers: Min Heap
	a. If heap size < k, push the element.
	b. If this element < top of heap, ignore.
	c. If this element > top && heap size == k, pop the top and insert this one.
	d. ALGO:
	    int findKthLargest(vector<int>& nums, int k) {    
	        priority_queue <int,vector <int>,greater <int> > pq;
	        for(int i=0;i<nums.size();i++){
	            if(pq.size()<k){
	                pq.push(nums[i]);
	            }
	            else{
	                if(pq.top()<nums[i]){
	                    pq.pop();
	                    pq.push(nums[i]);
	                }
	            }
	        }
	        return pq.top();      
	    }

25. Check if all leaves are at same level: 
	a. Set a var to the current level for the 1st leaf. All others should be that, if otherwise, return false.
	b. ALGO:
		bool checkLeavesSameLevel(node *root, int level, int *leaf_level){
		    if(root==NULL)
		        return true;
		    if(root->left == NULL && root->right==NULL){
		        if(*leaf_level==INT_MIN){
		            *leaf_level = level;
		            return true;
		        }
		        else if(*leaf_level == level)
		            return true;
		        else
		            return false;
		    }
		    else
		        return checkLeavesSameLevel(root->left, level+1, leaf_level) && checkLeavesSameLevel(root->right, level+1, leaf_level);
		}

26. Check if a Binary Tree is a BST or not
	a. For each node, there's a MAX val and MIN val. If your node doesn't follow that, return false.
	b. Check isBST for left and right child with proper min and max vals.
	c. ALGO:
		bool isBST(node *root, int mini, int maxi){
		    if (root==NULL)
		        return true;
		    if(root->data < mini || root->data > maxi)
		        return false;
		    return isBST(root->left, mini, root->data-1) && isBST(root->right, root->data+1, maxi);
		}

27. N-Queen Problem: Given n, print ALL possibilitites of placing n queens.
	a. ALGO:
		void solve(vector<vector<int>>& board, vector<vector<string>>& res, int col){
	        int n = board.size();
	        if(col == n) {
	            vector<string> s = convertAns(board);
	            res.push_back(s);
	            return;
	        }
	        
	        for(int i=0; i<n; i++){
	            if(board[i][col] == 0 && isValid(board, i, col)) {
	                board[i][col] = 1;
	                solve(board, res, col+1);
	                board[i][col] = 0;
	            }
	        }
	    }


28. Shortest Distance between two cells in a matrix: BFS with visited matrix.

29. Reverse a Linked List:
	a. This is the crux:
		current->next = NULL;
		while(nextNode != NULL){
            nextNextNode = nextNode->next;  // Save the nextnextNode address since while we reverse the direction, we would lose it.
            nextNode->next = current;       // Reverse the arrow
            current = nextNode;             // Move current ahead
            nextNode = nextNextNode;        // Move next Node ahead
        }
        head = current;
    b. If reverse needs to be done from index i till j:
    	i. Maintain a prev node since we need to connect prev to current now (instead of head)
    	ii. Maintain the first current since we need to attach it to the end.

30. Peak Element in the array: Binary Search

31. Diameter of a Binary Tree: Number of EDGES(not nodes) in the Longest Path between two nodes.
	a. Write the code for calculating the max Height of a tree.
	b. Introduce a variable called diameter which will calculate max(diameter, leftHeight+rightHeight) in all instances of recursion.
	c. ALGO:
	    int longestPath(TreeNode* node){
	        if(node == NULL)
	            return 0;
	        int leftPath = longestPath(node->left);
	        int rightPath = longestPath(node->right);

	        diameter = max(diameter, leftPath+rightPath);

	        return max(leftPath,rightPath)+1;
	    }

32. Count the frequency of an Element in a Sorted Array: Binary Search
	a. Calculate the Starting Index (Mid is target but mid-1 is not)& Ending Index(Mid is target but mid+1 is not)
	b. Calculate the difference between them.
	c. ALGO:
		int frequencyOfKey(vector<int> A, int K){
			return upper_bound(A.begin(),A.end(),K)-lower_bound(A.begin(),A.end(),K); //O(log(n))
		}

33. Merge Two sorted Arrays of size m and n into the first array which has size allocated as m+n
	a. Start from m-1 and n-1 of both arrays and keep allocating chars to m+n-1
	b. Put the remaining elements of arr2 into the first array if any.

34. Permutations of a String: Backtracking (O(n*n!))
	a. Call the permute func with l=0
	b. Permute would iterate for i=l till n
		i. Swap arr[i] and arr[l]
		ii. Call permute for l=l+1
		iii. Swap arr[i] and arr[l] back
	c. When l==n, it means one permuation is made, push it in result.
	d. The third backtrack would swap this instance back and then try for increased i
	e. ALGO:
		void permuteHelper(vector<int> nums, int l){
	        int n = nums.size()-1;
	        if(l == n){
	            result.push_back(nums);
	            return;
	        }
	        for(int i=l; i<=n; i++) {
	            swap(nums[i], nums[l]);
	            permuteHelper(nums, l+1);
	            swap(nums[i], nums[l]);
	        }
	    }

35. [OBSOLETE] Doubly Linked List: Usual Stuff.

36. Largest Region in Boolean Matrix / Max Area of an Island: Union Find with sizes / DFS with visited array
	a. ALGO:
		int dfs (vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j) {
		    if(i<0 || i==grid.size() || j<0 || j==grid[0].size() || visited[i][j] == 1 || grid[i][j] == 0)
		        return 0;
		    visited[i][j] = 1;
		    return 1+dfs(grid, visited, i+1, j)+dfs(grid, visited, i-1, j)+dfs(grid, visited, i, j+1)+dfs(grid, visited, i, j-1);
		}
		for(int i=0; i<m; i++) {
		    for(int j=0; j<n; j++) {
		        if (grid[i][j] == 1 &&  visited[i][j]==0){
		            area = dfs(grid, visited, i, j);
		            maxArea = max(area, maxArea);
		        }
		    }
		}
		return maxArea;

37. Median in a running Stream of Integers:
	a. Have a min heap for storing the max half of elements
	b. Have a max heap for storing the min half of elements
	c. Keep them balance while inserting the elements
	d. If num count is even, return average of both heaps. If odd, return the heap having more's top.

38. Reach the edge of the matrix in shortest distance: BFS with visited array

39. Clone Doubly Linked List with random pointer
	a. start traversing and insert duplicate nodes in between (current->next = new Node(current->val);)
	b. Fix random pointers in added nodes (current->next->random = current->random->next;)
	c. Detach the original and copied nodes (clone_current->next = clone_current->next->next)

40. First non-repeating character
	a. String: Put the freq in map and then iterate again. One having freq 1 is the ans.
	b. Stream of Integers: HashMap to store the freq of characters and queue to store the order of the characters.
		i. Insert the char in the map and check if the freq is 1, insert it in queue.
		ii. Check it in while loop, if this changed the freq of the queue from first character, remove it.
		iii. Queue's front will tell you the 1st Non-Repeating Character at all instances of time.

41. Intersection of two linked list:
	a. Travel the current nodes till the end then start from the other LL's head. They will meet at the intersecting index
	b. ALGO:
		if(headA == NULL || headB == NULL)
            return NULL;
        ListNode *cA = headA;
        ListNode *cB = headB;
        while (cA != cB){
            cA = (cA == NULL) ? headB : cA->next;
            cB = (cB == NULL) ? headA : cB->next;
        }
        return cA;

42. inorder, Pre-Order, Post-Order traversals: DFS, Stack

43. Maximum Sum of a Subarray of size K: Sliding Window of size K
	a. ALGO:
		int currentSum = 0;
	    int maxSum = INT_MIN;
	    int i = 0;

	    for(int j=0; j<arr.size() ; j++){
	        currentSum += arr[j];
	        int lengthOfWindow = j-i+1;
	        if(lengthOfWindow == k){
	            maxSum = max(maxSum, currentSum);
	            currentSum -= arr[i++];
	        }
	    }
	    return maxSum;

44. Maximum Number of all subarrays of size K: Deque
	a. Pop the elements from back of deque if arr[i] > arr[d.back()]
    b. When we've iterated >= k elements, then push the front of deque into ans
    c. While the front elements are going out of window, remove them.
    d. Push the current index in deque.
    	vector<int> ans;
        deque<int> d;
    	for(int i=0; i<arr.size();i++){
            while(!d.empty() && arr[i]>arr[d.back()])
                d.pop_back();
            if(i>=k) {
                ans.push_back(arr[d.front()]);
                if(!d.empty() && d.front() <= i-k)
                    d.pop_front();
            }
            d.push_back(i);
        }

45. Minimize the number of transactions (Splitwise Problem): 
	a. For disconnected graphs, we can apply DFS with backtracking to see all possible results and we choose the best fit (min transactions)
	b. Choose the transactions smartly, When they have opposite signs!
	c. ALGO:
		class Solution {
		public:
		    vector<int> debt;
		    int minTransfers(vector<vector<int>>& transactions) {
		        vector<int> balance(21, 0); // max 21 people involved.
		        int ans = 0;
		        for(auto t: transactions){
		            balance[t[0]] -= t[2];
		            balance[t[1]] += t[2];
		        }
		        
		        for(auto b: balance)
		            if(b != 0)
		                debt.push_back(b);
		        return dfs(0);
		    }
		    
		    // Returns the minimum number of transactions needed to settle the debt
		    int dfs(int s){
		        while(s < debt.size() && debt[s] == 0)
		            s++;
		        int res = INT_MAX;
		        for(int i=s+1; i<debt.size(); i++){
		            if(debt[i]*debt[s] < 0){
		                debt[i] += debt[s];
		                res = min(res, 1+dfs(s+1));
		                debt[i] -= debt[s];
		            }
		        }
		        return res == INT_MAX ? 0 : res;
		    }
		    
		};

46. Sorting.
	a. HeapSort gives us O(nlogn) for all cases with O(1) space.
	b. MergeSort gives us O(nlogn) for all cases with O(n) space.
	c. Quick Sort gives us O(nlogn) average but worst case O(n2) with O(logn) space.

47. Boundary Traversal of a Binary Tree:
	a. Print the left boundary in top-down manner without the leaves.
	b. Print all leaf nodes from left to right,
	c. Print the right boundary in bottom-up manner without the leaves.

48. LRU Cache: 
	a. We can use Hash and DLL as the data structures used for LRUCache implementation.
	b. Hash will store the key as the input number and the value would be the address of the node in the DLL.
	c. Algo:
		PUT: 
			If the element 'k' is in the map:
				Remove 'k' from its place in the DLL
				Add a node to the front of dll with {k,v}
				Update the address of key k in the map to DLL's front node.
			If the element 'k' is not in the map:
				If the cache is full:
					Pop the element from the back of DLL & erase from the map
					Add a node to the front of dll with {k,v}
					Update the address of key k in the map to DLL's front node.
				If the cache is not full:
					Add a node to the front of dll with {k,v}
					Update the address of key k in the map to DLL's front node.
		GET:
			If the element 'k' is in map
				Access the node from map value and return the {v} from {k,v} of the dll.
	d. DS:
		i. List of pairs: list<pair<int, int>> dll;
		ii. Map with keys as ints and vals as iterators/pointers of a list of pairs: unordered_map<int, list<pair<int, int>>::iterator> map;

49. Kanpsack Problem: DP / Greedy
	a. 0-1 Knapsack: Consider 2 cases- When not selecting this item with weight[i] and another When selecting this item with val[i] and wt[i]. 
					We want to maximize the val in our knapsack. There are n items and total weight Knapsack can hold is W.
		dp[n+1][W+1] = {0};
		for(i=0; i<=n; i++){
			for(j=0; j<=W; j++)
				if(j>=wt[i-1])
					dp[i][j] = max(dp[i-1][j], val[i-1] + dp[i-1][j-wt[i-1]]);
		return dp[n][W];

	b. Fractional Knapsack: Greedy
		i. Calculate the best val/wt item and sort the array on the max value/wt items criterion.
		ii. Keep putting the items in knapsak till you can't put a whole item since weight wouldn't allow.
		ii. Then fill the remaining knapsack with the remaining wt of the next item.

50. AVL Trees: Self Balancing Binary Search Trees, guarentees an upper bound of O(logN) in search, insert, delete, etc operations.

51. Bloom Filters: Probabilistic Data structure to test whether an element is in a set or not.
	a. Cons: You can not delete an element from Bloom Filters.
	b. TC: O(K) where K is the number of hash functions.

52. Stack:
	a. Reverse a Stack (using Recursion): 
		i. We keep popping the top elements using recursion and then pushing the top element in bottom. 
		ii. Pushing an element to the bottom is again a recursive function which keeps popping till its empty and then pushes the element. 
		iii. After that it pushes the other elements
		iv. O(n2)
		reverseStack(){
			if (!s.empty()){
				int t = s.top();
				s.pop();
				reverseStack();
				pushAtBottom(t);
			}
		}
		pushAtBottom(int t){
			if(s.empty()) {
				s.push(t);
			}
			else {
				int a = s.top();
				s.pop();
				pushAtBottom(t);
				s.push(a);
			}
		}

	b. Sort a Stack (using Recursion): Similar to reverse but here we push it in sortedOrder.
		i. We keep popping the top elements using recursion and then pushing the top element in sortedOrder.
		ii. Pushing an element in sorted order is again a recursive function which keeps popping till its place and then inserts it.
		iii. We will keep the stack sorted all the time so that step 2 can work.
		iv. TC: O(n2)
		sortStackRecursion(){
			if(!s.empty()){
				int t = s.top();
				s.pop();
				sortStackRecursion();
				pushInSortedOrder(t);
			}
		}
		pushInSortedOrder(int t){
			if(s.empty()){
				s.push(t);
			}
			else{
				if (s.top() < t){
					s.push(t);
				}
				else {
					int a = s.top();
					s.pop();
					pushInSortedOrder(t);
					s.push(a);
				}
			}
		}

	c. Sort a Stack using Temporary Stack: 
		while(!s1.empty()){
			int t = s1.top();
			s1.pop();
			while(!sortedStack.empty() && sortedStack.top() > t){
				s1.push(sortedStack.top());
				sortedStack.pop();
			}
			sortedStack.push(t);
		}

53. Count-Min-Sketch: Count the frequency of a letter in a stream of Integers.

54. Trapping Rain Water:
	a. Calculate the max bar to the left of every element: left[i] = max(left[i-1], arr[i])
	b. Calculate the max bar to the right of every element: right[i] = max(right[i-1], arr[i])
	c. Water arr[i] can store =min (max bar on left and right) - my own height => water += min(left[i],right[i]) - arr[i]
	d. Space Optimized Solution is to find the peak bar and calc water on left and right of it
	e. ALGO:
		int findWater(vector<int> arr){
		    int n = arr.size();
			vector<int> left(n), right(n);
			int water = 0;
			
			left[0] = arr[0];
			for(int i=1;i<n;i++)
				left[i] = max({arr[i], left[i-1]});

			right[n-1] = arr[n-1];
			for(int i=n-2;i>=0;i--)
				right[i] = max(right[i+1], arr[i]);
		    
			for(int i=0;i<n;i++)
				water += (min({left[i],right[i]}) - arr[i]);

			return water;
		}

55. Kth largest Integer in a BST: Reverse Inoder Traversal gives Kth largest element in O(k) time.
	a. Kth Smallest Integer in a BST is given by a normal inorder traversal in O(k) time.
	b. ALGO:
		void KthLargestIntegerInBST(node* root, int k, int &count) {
			if(root== NULL || count>k)
			    return;
			KthLargestIntegerInBST(root->right, k, count);
			count++;
			if (k== count){
				cout<<"The Kth largest integer in the BST is: "<<root->data<<" ";
				return;
			}
			KthLargestIntegerInBST(root->left, k, count);
		}

56. Best time to buy and sell stoack - I in one transaction
	a. Keep calculating minimum till today(minTillNow) & profit today = arr[i]-minTillNow
	b. Max Profit = max of all such profits.
	c. Algo:
		int maxProfit(vector<int>& prices) {
		    if(prices.size() <=1)
		        return 0;
		    int minTillNow = prices[0];
		    int maxProfit = 0;
		    
		    for(int i=0; i<prices.size(); i++){
		        minTillNow = min(minTillNow, prices[i]);
		        maxProfit = max(maxProfit, prices[i]-minTillNow);
		    }
		    return maxProfit;
		}

57. Add two numbers in Linked List: Calculate sum=x+y+carry and create nodes with sum%10 till both nodes become NULL. 
	Check for a final carry
	a. ALGO:
		ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
	        ListNode* c1=l1;
	        ListNode* c2=l2;
	        ListNode* l3head = new ListNode(0); //create this fake node 0 and in the end return l3head->next;
	        ListNode* c3 = l3head;
	        int carry = 0;
	        while(c1!= NULL || c2!=NULL){
	            int x = (c1 != NULL) ? c1->val : 0;
	            int y = (c2 != NULL) ? c2->val : 0;
	            int sum = (x+y+carry)%10;
	            carry = (x+y+carry)/10;
	            c3->next = new ListNode(sum);
	            c3 = c3->next;
	            if (c1!=NULL) 
	                c1 = c1->next;
	            if (c2!=NULL)
	                c2 = c2->next;
	        }
	        if(carry > 0)
	            c3->next = new ListNode(carry);
	        return l3head->next;
	    }

58. Longest Substring with no repeating Character: Sliding Window & a map to store the contents of window.
	a. If char is not already present in the map, we include it in map
	b. If it is present, we shorten the window from back and keep checking till we eliminate the char at j.
	c. ALGO:
		int lengthOfLongestSubstring(string s) {
		    if (s == "")
		        return 0;
		    unordered_map<char, bool> map;
		    int i = 0; // i is the starting of the flexi window
		    int j = 1; // j is the next element of the flexi window
		    int maxLen = 1;
		    map[s[0]] = true;
		    while(j != s.size()) {
		        if(map.find(s[j]) == map.end()){
		            map[s[j]] = true;
		            maxLen = max(maxLen, j-i+1);
		            j++;
		        }
		        else {
		            while(s[i]!=s[j]){
		                map.erase(s[i]);
		                i++;
		            }
		            map.erase(s[i]);
		            i++;
		        }
		    }
		    return maxLen;
		}
	d. VARIATION: Find the longest substring with at most K distinct characters
		int lengthOfLongestSubstringKDistinct(string s, int k) {
		    if(k == 0)
		        return 0;
		    unordered_map<char, int> map;
		    int i=0, j=1, maxLen=1;
		    map[s[i]]=1;
		    while(j<s.size()){
		        if(map.count(s[j])){
		            map[s[j]]++;
		            maxLen = max(maxLen, j-i+1);
		            j++;
		        }
		        else if(map.size() < k){
		            map[s[j]]++;
		            maxLen = max(maxLen, j-i+1);
		            j++;
		        }
		        else {
		            while(i<j) {
		                map[s[i]]--;
		                if(map[s[i]] == 0){
		                    map.erase(s[i]);
		                    i++;
		                    break;
		                }
		                i++;
		            }
		            map[s[j]] = 1;
		            j++;
		        }
		    }
		    return maxLen;
		}

59. Longest Palindromic Subarray/Subsequence: 
	Longest Palindromic Subarray:
		a. We check for palindromes with center at i,i and center at i,i+1 and expand around teh center.
		b. We keep checking if elements are same or not in the string.
		c. This algo is O(n2) but Manachers Algo does it in O(n)
		d. ALGO:
			string longestPalindrome(string s) {
			    if(s.size()<= 1)
			        return s;
			    int i = 0;
			    string lps = "";
			    while(i<s.size()){
			        string s1 = expandFromMiddle(s, i, i);
			        string s2 = expandFromMiddle(s, i, i+1);
			        
			        string str = s1.size() > s2.size() ? s1 : s2;
			        if(str.size() > lps.size())
			            lps = str;
			        
			        i++;
			    }
			    return lps;
			}
			
			string expandFromMiddle(string s, int left, int right){
			    while(left>=0 && right<s.size() && s[left]==s[right]){
			        left--;
			        right++;
			    }
			    return s.substr(left+1, right-left-1); // right-1-(left+1) +1
			}

	Longest Palindromic Subsequence:
		a. ALGO:
			int longestPalindromeSubseq(string s) {
			    int n = s.size();
			    vector<vector<int>> dp(n, vector<int>(n));
			    
			    for(int i=0; i<n; i++){
			        dp[i][i] = 1;
			        for(int j=i-1; j>=0; j--){
			            if(s[i] == s[j])
			                dp[i][j] = 2 + dp[i-1][j+1];
			            else
			                dp[i][j] = max(dp[i-1][j], dp[i][j+1]);
			        }
			    }
			    
			    return dp[n-1][0];
			}

60. Maximum water in a container: Two-Pointer. Keep two indexes left and right and keep calculating the area between them till they meet.
	a. ALGO:
		class Solution {
		public:
		    int maxArea(vector<int>& arr) {
		        int n = arr.size();
		        int left=0, right=n-1;
		        int maxWater=0;
		        while(left<right){
		            int area = min(arr[left], arr[right])*(right-left);
		            maxWater = max(area, maxWater);
		            if(arr[left] < arr[right])
		                left++;
		            else
		                right--;
		        }
		        return maxWater;
		    }
		};

61. Next Permutation of a Number:
	a. Find the largest index i such that arr[i-1] < arr[i] (0125330 -> 012'5'330, a[i]->5) [Upward Slope]
	b. If no such i exists, Then the array is already sorted decending. We just need to reverse (321 -> 123)
	c. Finding the greatest index j such that j>=i and arr[j]>arr[i-1] (01'2'5330 -> 01253'3'0, a[i-1]=2, a[j]=3)
	d. Swap arr[j] and arr[i-1] (0125330 -> 0135320)
	e. Reverse the suffix since we want the next perm, so it has to be the smallest (013|5320 -> 013|0235)


62. Merge Intervals: Sort and then Keep checking for overlapping. If overlapping, update the end index. if not, then insert

63. Evaluating Division: DFS with Backtracking. Using the visited array as well.
	a. The problem can also be thought as: Given two nodes in a graph, we are asked to check if there exists a 
		path between them. If so, we should return the cumulative products along the path as the result.
	b. ALGO:
		
		if(!graph.count(Qdividend) || !graph.count(Qdivisor))
            results[i] = -1.0;
        else if (Qdividend == Qdivisor)
            results[i] = 1.0;
        else {
            unordered_set<string> visited;
            results[i] = backtrackEvaluate(graph, Qdividend, Qdivisor, 1, visited);
        }


        double backtrackEvaluate(unordered_map<string, unordered_map<string, double>>& graph, string& currentNode, string& targetNode, double accProduct, unordered_set<string>& visited) {
	        visited.insert(currentNode);
	        double ret = -1.0;
	        unordered_map<string, double> neighbours = graph[currentNode];

	        if(neighbours.count(targetNode)){
	            ret = accProduct * neighbours[targetNode];
	        }
	        else {
	            for(auto n: neighbours){
	                string Nnode    = n.first;
	                double Nweight  = n.second;
	                if(visited.count(Nnode))
	                    continue;
	                ret = backtrackEvaluate(graph, Nnode, targetNode, accProduct*Nweight, visited);
	                if(ret != -1.0)
	                    break;
	            }
	        }
	        visited.erase(currentNode);
	        return ret;
	    }



64. Number of subarrays where Product of elements < K
	a. Algo:
		int result = 0, start = 0, end = 0, n = nums.size();
        int product = 1;
		while(end<n){
	        product *= nums[end];
	        while (start < end && product >= k)  
	            product /= nums[start++];
	        result += (end-start)+1;
	        end++;
    	}

65. Rotate a matrix clockwise 90*: We can rotate an image by first transposing and then swapping along the leading diagonal.
	  	
	a. Algo:
		for(int i=0;i<n/2;i++)
      		for(int j=0;j<n;j++)
        		swap(a[i][j], a[n-1-i][j]);
    
	    for(int i=0;i<n;i++)
	     	for(int j=i+1;j<n;j++)
	        	swap(a[i][j], a[j][i]);
	b.
	  	1 2 3      7 8 9      7 4 1
		4 5 6  =>  4 5 6  =>  8 5 2
		7 8 9      1 2 3      9 6 3

66. Word Break Problem: Recursion + Memoization
	a. If my dictionary contains s[start..end] and s[end..n] can also be solved, return true
	b. memo[] will contain whether a word 'w' can be solved or not. -1 = UNKNOWN, 0=CANNOT, 1=CAN
	c. Algo:
		if (memo[start]!= -1)
      		return memo[start];

		for(int end=start+1;end<=n;end++){
	      	if (dictMap.find(s.substr(start,end-start)) != dictMap.end()  && wordBreakHelper(s, dictMap, end, memo)){
	        	memo[start] = 1;
	        	return true;
	      	}
	    }

	    memo[start] = 0;
	    return false;

67. Longest Substring with at most 2 distinct characters: Sliding Window

68. Merge Two Sorted Linked Lists:
	a. Algo:
		if(l1 == NULL)
			return l2;
		if(l2 == NULL)
			return l1;
		if(l1->val < l2->val)
			l1->next = merge(l1->next, l2)
			return l1;
		else
			l2->next = merge(l1, l2->next)
			return l2;


69. Coin Changing 3 : Given infinite coins, print the ways in which we can make a sum s.
	a. Iterate the DP array and try to calculate it.

70. Topological Sort: BFS on nodes with indegree 0
	a. Calculate the indegree for all the vertices.
	b. Push the vertices with indegree 0 in a queue.
	c. Till the queue is empty, for all the adjacent nodes of the popped node, decrease the indegree & if it is 0, push it in queue
	d. Keep pushing the popped nodes in the ans. This will be the TOPOLOGICAL SORT of the graph.
	e. Keep maintaining the number of nodes that are visited & if that is not equal to total vertices, there are cycles.

71. Serialize and Deserialize a BST
	a. Save it in Pre-Order Traversal
	b. Construct BST from Pre-Order Traversal with help of MIN and MAX arguments for each node.

72. Minimize arrows to burst balloons.
	a. Sort them on start time.
	b. Iterate over the balloons and if they overlap (lastIntervalEndtime > NewIntervalStartTime, then keep only overlapping intervals.
	c. If they do not overlap, then keep current intervals end time as the last interval end time.

73. Sort a Linked List: Using Merge Sort here.

74. Minimum Number of Meeting Rooms: Priority Queue.
	a. Sort the meetings on start time.
	b. Maintain a PQ(min heap) and insert the meeting end times.
	c. If a meeting is later than the pq top, then pop the last one and insert this one.
	d. If a meeting overlaps with the pq top, then insert this one.
	e. Size of pq will be the required meeting rooms.
	f. ALGO:
		sort(intervals.begin(), intervals.end());
        priority_queue<int, vector<int>, std::greater<int>> pq;
        pq.push(intervals[0][1]);
        for(int i=1;i<intervals.size();i++){
            if(intervals[i][0] >= pq.top())
                pq.pop();
            pq.push(intervals[i][1]);
        }
        return pq.size();

75. Best Time to Buy and Sell Stock 2: Given stock prices and with infinite transactions, maximize the profit.
	a. We can consider all the small profits on each consecutive day since adding them up will make up a big profit.
	b. ALGO:
		for(int i=1;i<prices.size();i++){
            profit += max(prices[i]-prices[i-1] ,0);
        }

76. Best Time to Buy and Sell Stock 3: Given stock prices and with K transactions, maximize the profit. DP.
	a.	dp[i][j] represents the max profit one can make with at most i transactions in j days

		dp[i][j] = max( 
	        1. Not transacting on jth day = dp[i][j-1]
	        2. Selling on jth day and buying on m=0..(j-1) th day + 
	            profit made till mth day with i-1 transactions
	                =(price[j]-price[m]+dp[i-1][m])
	                =(dp[i-1][m]-price[m]+price[j])
        )

	b. ALGO:
		long int dp[k+1][d];
		for(long int i=0;i<d;i++)
            dp[0][i] = 0;
        for(long int i=0;i<k+1;i++)
            dp[i][0] = 0;
		for(long int i=1;i<k+1;i++){
            long int max_diff = dp[i][0] - prices[0];
            for(long int j=1; j<d; j++){
                max_diff = max(max_diff, dp[i-1][j]-prices[j]);
                dp[i][j] = max(dp[i][j-1], max_diff+prices[j]);
            }
        }
		return dp[k][d-1];

77. Clone an Undirected Graph:
	DFS: 
		a. NULL Check
		b. Visited Check.
		c. Create new Node.
		d. Update visited,
		e. Iterate over all neighbours and assign the node to the neighbours. Return the cloned Node.
		f. ALGO:
			if(node == NULL)
	            return NULL;
	        if(visited.count(node))
	            return visited[node];
	        Node* cloneNode = new Node(node->val);
	        visited[node] = cloneNode;
	        for(auto nbr : node->neighbors)
	            cloneNode->neighbors.push_back(cloneGraph(nbr));
	        return cloneNode;

	BFS:
		a. ALGO:
			unordered_map<Node*, Node*> visited;
		    visited[node] = new Node(node->val); // (1->1*)
		    queue<Node*> q;
		    q.push(node);
		    while(!q.empty()){
		        Node* top = q.front();
		        q.pop();
		        for(auto &nbr: top->neighbors){ // 1->[2,3]
		            if(!visited[nbr]){
		                visited[nbr] = new Node(nbr->val);
		                q.push(nbr);
		            }
		            (visited[top]->neighbors).push_back(visited[nbr]); // 1* -> [2*, 3*]
		        }
		    }


78. Print all nodes at a distance K from target: BFS with visited since the tree has become some what like a graph
	a. Create a hashmap for child->parent traversal.
	b. Write BFS, just we need to insert the parent node as well by checking from the hashmap.
	c. When you reach K level break, all nodes in the queue will be of level K.
	d. ALGO:
		queue<TreeNode*> q;
        int currentLevel = 0;
        q.push(target);
        visited[target] = true;
        while(!q.empty()){
        	if (currentLevel == K)
                break;
            currentLevel++;
            int size = q.size();
            for(int i=0; i<size; i++) {
                TreeNode* front = q.front();
                visited[front] = true;
                q.pop();
                if (front->left && !visited[front->left])
                    q.push(front->left);
                if (front->right && !visited[front->right])
                    q.push(front->right);
                if (parents[front] && !visited[parents[front]])
                    q.push(parents[front]);
            }
        }
        vector<int> res;
        while(!q.empty()){
            TreeNode *f = q.front();
            q.pop();
            res.push_back(f->val);
        }

79. Word Ladder: Transform a word from startWord to endWord from a wordlist by making one change at a time. BFS
	a. Add startWord to queue.
	b. Try to change all its letters and check if you have it in dict. If you have, insert it in queue.
	c. Keep doing this till you find endWord
	d. Keep erasing the words that yu have made form dict since otherwise you may fall in an infinite loop.
	e. Since it is BFS, it will give you the shortest way to arrive from beginWord to endWord.

80. Coin Changing 4: Minimum number of coins required to create a sum.
	a. dp[j] = min(dp[j], dp[j-coins[i]]+1);

81. Minimum Number of Jumps to reach the end of array.
	a. Start from 0 till currentEnd(0 init) and keep calculating the currentFarthest you can reach.
	b. Once you reach the end, make currentEnd = currentFarthest and increase a jump.
	c. Algo:
		for(int i=0; i<n-1;i++) {
            currFarthest = max(currFarthest, i+nums[i]);
            if (i == currEnd){
                jumps++;
                currEnd = currFarthest;
                if(currEnd >= n-1)
                    break;
            }
        }

82. Number of palindromic Substrings:
	a. Use the same logic of expand_from_middle and this time, return the number of strings instea of the boolean.

83. Longest String Chain: DFS + Backtracking
	a. ALGO:
		if (memo.find(currentWord) != memo.end())
            return memo[currentWord];
        int n = currentWord.size();
        int maxLength=1;
        for(int i=0; i<n; i++) {
            string newWord = currentWord.substr(0, i) + currentWord.substr(i+1, n);
            if (wordsPresent.find(newWord) != wordsPresent.end()) {
                int len = dfs(wordsPresent, memo, newWord)+1;
                maxLength = max(len, maxLength);
            }
        }
        memo[currentWord] = maxLength;
        return maxLength;

84. Longest Increasing Path in a Matrix: DFS + visited array
	a. We use DFS with visited cache to solve this.
	b. ALGO:
		if(cache[i][j]!=1){
            return cache[i][j];
        }
        
        vector<int> x = {1, -1, 0, 0};
        vector<int> y = {0, 0, 1, -1};
                 
        for(int k = 0; k <4; k++){
            if( i+x[k]>=0 && i+x[k]<m && j+y[k]>=0 && j+y[k]<n && 
                matrix[i+x[k]][j+y[k]] > matrix[i][j] ){
                cache[i][j] = max(cache[i][j], dfs(matrix, cache, i+x[k], j+y[k]) + 1);
            }
        }
        return cache[i][j];

85. Range Sum Query - Mutable (Update can happen): Segment Tree.
	Range Sum Query - Immutable (No update, only sum): Prefix Sum.

86. K-Closest points to the origin: Max Heap of size K.
	
87. Median of Two Sorted Arrays X & Y: Binary search to find the middle elements and then cal the median.
	a. Find the cut using Binary search in the smaller array X
	b. Find the corresponding cut in Y: ((x+y+1)/2 - cutX)
	c. Calc the elements leftX, leftY, rightX, rightY which are beside the cuts
	d. If leftX <= rightY && leftY <= rightX, then we calc the median and return since we found the cut.
	e. If leftX > rightY, we shift left, otherwise if leftY > rightX shift right
	f. If x+y = odd len, then left has the median as max(leftX, leftY)
	g. If x+y = even len, then median = avg(max(leftX, leftY), min(rightX, rightY))
	h. ALGO:
		if (nums1.size() > nums2.size())
            return findMedianSortedArrays(nums2, nums1);
        int x = nums1.size(); int y = nums2.size();
        int low = 0; int high = x;
        while(low <= high){
            int partX = (low+high)/2;
            int partY = (x+y+1)/2 - partX;

            int LeftX = (partX==0)? INT_MIN : nums1[partX-1];
            int RightX = (partX==x)? INT_MAX : nums1[partX];
            int LeftY = (partY==0)? INT_MIN : nums2[partY-1];
            int RightY = (partY==y)? INT_MAX : nums2[partY];
            
            if (LeftX <= RightY && LeftY <= RightX)
                if( (x+y)%2 == 0)
                    return (double) (max(LeftX, LeftY)+min(RightX,RightY))/2;
                else
                    return (double) max(LeftX, LeftY);
            else if (LeftX > RightY)
                high = partX-1;
            else // LeftY > RightX
                low = partX+1;
        }

88. Remove Minimum Parentheses to Make Valid String: Stack
	a. We use stack to store the INDEXES of '(' and when we see a ')', we pop a '(' from our stack.
	b. If we get a ')' and the stack is empty, we remove this '(' from our final string.
	c. If we have remaining '(' in our stack after the whole string is parsed, we ignore them from final string.

89. Insert an item, Delete an item, & GetRandom Element from set in O(1) time: 
	a. Use vector to store the elements and hashmap to check if it is already present
	b. Insert it in O(1) time in vector and update map with val->index
	c. Remove it in O(1) time by copying last element to val's index and then pop_back()
	d. Get random in O(1) by choosing a random number from 0 to vector.size()

90. Count Number of Subarrays with sum=K
	a. We use a hash map to store the cumulative sum till now and it's freqeuncy.
	b. We check if sum-k is already in the map, then it means that the sum "sum-k" has already been encountered 
		map[sum-k] number of times and from there till i, we can make the sum "k", so ans += map[sum-k]
	c. ALGO:
		int ans=0, sum=0;
        unordered_map<int, int> freq = {{0, 1}};
        
        for(int i=0; i<nums.size(); i++){
            sum+= nums[i];
            if(freq.count(sum-k))
                ans+= freq[sum-k];
            freq[sum]++;
        }
        return ans;
	d. Similar Prob: Calc Max Length of array with sum=K. Here we store the indexes of elements instead of freq of sum.
	e. ALGO:
		int ans=0, sum=0;
        unordered_map<int, int> map;
        map[0] = -1;
        for(int i=0; i<a.size(); i++){
            sum+=a[i];
            if(map.count(sum-k))
                ans = max(ans, i-map[sum-k]);
            if(!map.count(sum))
                map[sum] = i;
        }
        return ans;

91. Add two strings without using the inbuilt functions.
	a. We use the generic method of adding with help of carry
	b. By taking two pointers from string's (n-1)th index till 0, we keep adding it with carry.
	c. ALGO:
		int carry = 0;
		int p1 = nums1.size()-1;
		int p2 = nums2.size()-1;
		while(p1>=0 || p2>=0) {
			int x = (p1 >= 0 ? nums1[p1]-'0' : 0);
			int y = (p2 >= 0 ? nums1[p2]-'0' : 0);
			int value = (x+y+carry)%10;
			carry = (x+y+carry)/10;
			ans += to_string(value);
			p1--; p2--;
		}
		if(carry !=0)
			ans += to_string(1);
		reverse(ans.begin(), ans.end());
        return ans;

92. LFU Cache: TODO

93. Search in a rotated sorted array: Binary Search
	a. B.Search for the index of the lowest element. (TRICKY to remember this variation of Binary Search)
	b. Check in which sorted side we need to search for target.
	c. B.Search for the target in the sorted array.
	d. ALGO:
		int low = 0, high = n-1;
        while(low < high){
            int mid = low + (high-low)/2;
            if (v[mid] > v[high])
                low = mid+1;
            else
                high = mid;
        }
        int index_lowest = low;
        if (target == v[index_lowest])
            return index_lowest;

        if (index_lowest == 0)
            low=0, high=n-1;
        else if (target >= v[0])
            low=0, high=index_lowest-1;
        else if (target < v[0])
            low=index_lowest, high=n-1;
        
        while(low <= high){
            int mid = low + (high-low)/2;
            if(v[mid] == target)
                return mid;
            else if (v[mid] > target)
                high = mid-1;
            else 
                low = mid+1;
        }
        return -1;

94. Number of Connected Nodes in a Graph: DFS/BFS/UnionFind
	DFS:
	a. The input is an adjacency matrix. We take a visited array of size n
	b. We iterate over for i from 0 .. n and check if it is not visited, call the dfs()
	c. In DFS, we iterate for j over the ith row again and then check if we have not visited and grid is 1, then visit it and call dfs on that j
	d. ALGO:
	    void dfs(vector<vector<int>>& grid, vector<int>& visited, int i){
	        for(int j=0; j< grid.size(); j++){
	            if(i!=j && grid[i][j] == 1 && visited[j] == 0){
	                visited[j] = 1;
	                dfs(grid, visited, j);
	            }
	        }
	    }
	    
	    for(int i=0; i<n; i++){
	        if(visited[i] == 0) {
	            dfs(grid, visited, i);
	            count++;
	        }
	    }
	    return count;
    
    BFS:
    a. We iterate over the row and if the node is not visited, we push it in queue and then do BFS over it.
    b. ALGO:
        vector<int> visited(n, 0);
        queue<int> q;
        int ans=0;
        for(int i=0; i<n; i++){
            if(visited[i] == 0){
                q.push(i);
                while(!q.empty()) {
                    int top = q.front();
                    q.pop();
                    visited[top] = 1;
                    for(int j=0; j<n; j++){
                        if(isConnected[top][j]==1 && visited[j]==0)
                            q.push(j);
                    }
                }
                ans++;
            }
        }
        return ans;

95. House Robber: You can rob alternate houses present in a row stacked with some money. Calc max money
	a. ALGO:
		dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for(int i=2;i<n;i++)
            dp[i] = max(dp[i-1], dp[i-2]+nums[i]);
        return dp[n-1];
    b. Variation: What if H1 is connected with Hn in a circular way. Houses arranged in a circle.
    	i. Consider two house robber problems: (House[1] to House[n-1]) or (House[2] to House[n])
    	ii. ALGO:
			dp[0] = nums[0];
			dp[1] = max(nums[0], nums[1]);
			for(int i=2;i<n-1;i++)
			  dp[i] = max(dp[i-1], dp[i-2]+nums[i]);
			int ans1 = dp[n-2];

			dp.clear();
			dp[0] = nums[1];
			dp[1] = max(nums[1], nums[2]);
			// Robbing house 1 to n-1 (loop is same just accessing nums[i+1] instead of nums[i])
			for(int i=2;i<n-1;i++)
			  dp[i] = max(dp[i-1], dp[i-2]+nums[i+1]);
			int ans2 = dp[n-2];

			return max(ans1, ans2);

96. Convert Integer to Roman:
	a. ALGO:
		vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};    
		vector<string> symbols = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};

		string intToRoman(int num) {
		    string ans;
		    for(int i=0; i<values.size() && num > 0; i++){
		        while(values[i] <= num) {
		            num -= values[i];
		            ans += symbols[i];
		        }
		    }
		    return ans;
		}

97. Find Minimum/Maximum in a stack:
	a. We need to store the minimum at every point of time in the stack so that we can output it in O(1) time.
		Hence, instead of stack<int>, we will have a stack<pair<int, int>>
	b. While pushing we can check this value and last min value and decide on the current min value.
	c. popMIN()/ popMAX() - You have to pop the minimum here 
		- Till the num and the min become equal, we keep popping the pairs and push it in another temp stack.
		- Once they are equal, we pop it and then push the nums from temp stack to original stack.
		- We need to recalculate the min for all of them again, so we use the PUSH method that we defined
			which actually checks the current min and element value to select the current min and then push

98. First Missing Positive in the given unsorted array:
	a. Check for 1 in the array, if not, 1 is the answer.
	b. Convert all the 0s, -ves, and numbers > n to be 1 since they can not be FMP. It must lie between 1 to n+1
	c. Iterate over the elements and convert nums[nums[i]] to be negative. Use index 0 for n since index n is not available.
		int a = abs(nums[i]);
        nums[a] = -abs(nums[a]);
    d. Iterate and see if a number > 0, then that index is the FMP. If not, then n+1 is FMP.
    e. TC: O(n)
    f. ALGO:
    	for(int i=0;i<n;i++){
            if(nums[i] == 1){
                found1 = true;
                break;
            }
        }
        if (found1){
            for(int i=0;i<n;i++){
                if(nums[i] <= 0 || nums[i] > n)
                    nums[i] = 1; 

            for(int i=0;i<n;i++){
                int a = abs(nums[i]);
                if(a == n)
                    nums[0] = -abs(nums[0]);
                else
                    nums[a] = -abs(nums[a]);
            }
            for(int i=1;i<n;i++)
                if(nums[i] > 0)
                    return i;

            if(nums[0] > 0)
                return n;

            return n+1;
        }
        else
            return 1;


99. Print Matrix in Spiral Order:
	a. Imagine 4 rods (m_start, m_end) in rows (n_start, n_end) in columns
    b. Just keep walking on the rods
    c. Once walked, bring the rods closer to each other and keep doing this till they overlap
    d. When m_start and m_end are overlapping, do not traverse the same thing left->right 
        and then right->left. Similarly, for n_start and n_end
    e. ALGO:
    	int m_start = 0, m_end   = m-1, n_start = 0, n_end   = n-1;
        vector<int> ans;
        while(m_start <= m_end && n_start <= n_end){
            
            for(int i=n_start;i<=n_end;i++)
                ans.push_back(matrix[m_start][i]);

            for(int i=m_start+1; i<=m_end-1; i++)
                ans.push_back(matrix[i][n_end]);
            
            if (m_start != m_end)
                for(int i=n_end; i>=n_start; i--)
                    ans.push_back(matrix[m_end][i]);
            
            if (n_start != n_end)
                for(int i=m_end-1; i>=m_start+1; i--)
                    ans.push_back(matrix[i][n_start]);
            
            m_start++; m_end--;
            n_start++; n_end--;
        }
        return ans;

100. Sudoku Solver: Classic Backtracking
	a. PseudoCode:
	solve(board)
		Iterate over matrix both loops in row(i), col(j)
			if empty cell (grid[i][j] = '.')
				Iterate over all chars possible(k->1..9)
					Check if valid palcement 
						Place k in grid[i][j]
						if (solve(board))
							return true;
						else
							grid[i][j] = '.'
				return false since none of the 'k' worked for us here. Some other placement was wrong, backtrack.
		return true if we are able to reach here after placing everything.

	b. ALGO:
	    bool isValidPlacement(vector<vector<char>>& board, int row, int col, char c){
	        for(int i=0;i<9;i++)
	            if(board[row][i] == c) return false;
	        for(int i=0;i<9;i++)
	            if(board[i][col] == c) return false;
	        
	        for(int i=0;i<3;i++)
	            for(int j=0;j<3;j++)
	                if(board[row/3*3 + i][col/3*3 + j] == c)
	                    return false;
	        return true;
	    }
	    
	    
	    bool solve(vector<vector<char>>& board){
	        for(int i=0;i<9;i++){
	            for(int j=0;j<9;j++){
	                if(board[i][j] == '.'){
	                    for(int k=0;k<9;k++){
	                        if(isValidPlacement(board, i, j, k+'1')){
	                            board[i][j] = '1'+k;
	                            if(solve(board))
	                                return true;
	                            else
	                                board[i][j] = '.';
	                        }
	                    }
	                    return false;
	                }
	            }
	        }
	        return true;
	    }

	c. Time complexity is constant here since the board size is fixed and there is no N-parameter 
    to measure. Though let's discuss the number of operations needed.
	    Let's consider one row, i.e. not more than 9 cells to fill. 
	    There are not more than 9 possibilities for the first number to put, 
	    not more than 98 for the second one, not more than 987 for the third one etc. 
	    In total that results in not more than 9! possibilities for a just one row, that means 
	    not more than (9!)^9 operations in total.

101. Letter Combination of a Phone Number:
	a. Have a map of numbers -> string mapping
	b. Iterate over all the digits of input numbers and get the corresponding string of that letter from the map.
	c. Iterate over the already present answer vector and then over the new set of letters from this digit
	d. Concatenate the new letters with all the answers already present and make a new array out of it.
	e. This new set becomes your answer. Iterate over this referring as ans for all the other numbers.
	f. ALGO:
		for(int i=0;i<n;i++){
            string letters = map[digits[i]];
            if(ans.empty()) {
                for(int j=0;j<letters.size();j++){
                    string s; s += letters[j];
                    ans.push_back(s);
                }
            }
            else {
                vector<string> new_ans;
                for(int j=0;j<letters.size();j++)
                    for(int k=0;k<ans.size(); k++)
                        new_ans.push_back(ans[k]+letters[j]);
                ans = new_ans;
            }
        }
        return ans;
    g. TC: O(4^N * N) (1 number: 4 paths, 2 numbers 16 paths, 3 numbers 64 paths... so 4^N) and then if join taken O(n) time, consider that as well.

102. [DUPLICATE-62] Merge Intervals

103. Pythagorean Triplets: Return true if an array has Pythagaurean Tripet in it (a2+b2=c2)
	a. Square all the elements of the array
	b. Store all the squared numbers in a map to know if a number n is present in array or not. Value would be the index.
		- The problem now reduces to a Two sum problem with target present inside the array itself.
	c. We iterate over the array twice and check if arr[i]+arr[j] is present in map and map[arr[i]+arr[j]] !=i && !=j, then return true.
	d. ALGO:
		for(int i=0; i<n; i++){
	        arr[i] = arr[i]*arr[i];
	        map[arr[i]] = i;
	    }

	    for(int i=0; i<n-1; i++)
	        for(int j=i+1; j<n; j++)
	            if (map.count(arr[i] + arr[j]) && map[arr[i]+arr[j]] != i && map[arr[i]+arr[j]] != j)
	                return true;

	    return false;
	e. TC: O(n2), SC: O(n)

104. Verifying Alien Dict: Given a new order of chars, check if some words are sorted int in that order.
	a. Get the new order into a map and map every letter to 1->26 in the new order
	b. Then iterate for each word[i] and word[i+1] checking if they are in the "new order"
	c. ALGO:
		unordered_map<int, int> map;
        for(int i=0; i<order.size(); i++){
            map[order[i]] = i+1;
        }
        
        for(int i=0;i<words.size()-1; i++){
            if(!checkLexographic(words[i], words[i+1], map))
                return false;
        }
        return true;

        bool checkLexographic(string a, string b, unordered_map<int, int> map){
	        int i=0, j=0;
	        while(i!=a.size() && j!=b.size() && a[i]==b[j])
	            i++; j++;
	        
	        if( (i== a.size()) || (i!=a.size() && j!=b.size() && map[a[i]] < map[b[j]]) )
	            return true;
	        else
	            return false;
	    }

105. Convert Integer to English word.
	a. Have functions one,twoLessThan20, ten, two, three which return the relevant spellings.
	b. Call these functions and try to convert the whole number.

106. Check is a string is a valid palindrome after at most 1 deletion.
	a. Two Pointers: i and j and traverse the string from start and end.
	b. While the chars keep matching, i++, j--
	c. Once the letters dont match, check for isPalindrome(i+1, j) || isPalindrome(i, j-1)
	d. If any of them returns true, then return true, else false.
	e. ALGO:
		int i=0, j=n-1;
        while(i<j){
            if(s[i]!=s[j])
                return isPalin(s, i+1, j) || isPalin(s, i, j-1);
            i++; j--;
        }
        return true;

        bool isPalin(string s, int l, int r){
	        int i=l, j=r;
	        while(i<j){
	            if(s[i] != s[j])
	                return false;
	            i++; j--;
	        }
	        return true;
	    }

107. Check if an array is a permutation of 1 to n.
	a. Keep iterating and converting the numbers present index of current num to be negative.
		for(int i=0;i<n;i++){
			int abs_vi = abs(v[i]);
			v[abs_vi] = -v[abs_vi];
		}
	b. Finally if there is any number > 0, then it means that array is not a perm, otherwise true.

108. Maximum Level Sum of a Binary Tree: BFS 
	a. Simple BFS in which we keep calc sum of each level and then maxSum out of the all level sums.

109. Skyline Problem: TODO

110. Shortest Distance between 2 islands: FloodFill, DFS.
	a. Iterate over one island and convert all 1s to 2s, then exit.
	b. Iterate over the 2s and create a boundary of 3s beside it, then iterate over 3s to create a boundary of 4s
		(we call this color)... till we reach an island of 1s
		- We use the expand() function to color WITH 2s, 3s...
	c. When we reach an island of 1s, the color for example is c, then c-2 is the minimum distance between 2 islands.
	d. ALGO:

    int dfs(vector<vector<int>>& grid, int i, int j){
        if (i<0 || j<0 || i==grid.size() || j==grid.size() || grid[i][j]!= 1) 
            return 0;
        grid[i][j] = 2;
        return 1 + dfs(grid, i+1, j) + dfs (grid, i-1, j)+ dfs(grid, i, j+1) + dfs(grid, i, j-1);
    }
    
    bool expand(vector<vector<int>>& grid, int i, int j, int cl) {
        if (i<0 || j<0 || i==grid.size() || j==grid.size()) 
        	return false;
        if (grid[i][j] == 0) 
            grid[i][j] = cl+1;
        return grid[i][j] == 1;
    }
    
    for(int i=0; !found && i<grid.size(); i++)
        for(int j=0; !found && j<grid.size(); j++)
            found = dfs(grid, i, j);
    for (int cl = 2; ; ++cl)
        for(int i=0; i<grid.size(); i++)
            for(int j=0; j<grid.size(); j++)
                if (grid[i][j] == cl && (expand(grid, i - 1, j, cl) || expand(grid, i, j - 1, cl) || expand(grid, i + 1, j, cl) || expand(grid, i, j + 1, cl)))
                    return cl-2;
    
111. Rectangles Overlap: Check if two given rectangles overlap with each other.
	a. Instead of overlap, check for conditions on when they will not overlap.
	b. ALGO:
		// x2 <= x3 when R1 is on the left of R2 and they do not intersect
        // x4 <= x1 when R2 is on the left of R1 and they do not intersect
        if(x2 <= x3 || x4 <= x1)
            return false;
        
        // y2 <= y3 when R2 is above R1 and they do not intersect
        // y4 <= y1 when R1 is above R2 and they do not intersect
        if (y2 <= y3 || y4 <= y1)
             return false;

112. Reverse Nodes in a LinkedList in groups of size K
	a. 
			 head-> 1->2 -> 3->4 -> 5 (k=2)
    Step#1:  head-> 2->1 -> 3->4 -> 5
    Step#2:  head-> 2->1 -> 4->3 -> 5

        1. Check if K nodes are present from the current node so that we can reverse them.
        2. Reverse the set of K nodes.
        3. After reversing each set, we have to do two more things:
             b. Connect THIS reversed set to the following node (1->3 in step#1, 3->5 in step#2)
                 This is done in the reverseKNodes() with the line (firstCurrent->next = nextNode)
             a. Connect the prev reversed set's last node to THIS reversed set (head->2 in step #1, 1->4 in step#2)
                 This is done in the reverseKGroup() with the line (lastNodeInPrevKNodeSet->next = newCurrentNode)

113. Merge Sorted Arrays: arr1 has m+n space but m elements, arr2 has n elements. Both are sorted. Merge into arr1.
	a. Iterate from pointers m-1(i) of arr1 and n-1(j) of arr2.
	b. Compare these iterators and save the max at arr1s m+n-1(k)
	c. Increase/Decrease the iterators i/j and k.
	d. ALGO: (TC: O(n+m), SC: O(1))
		int i=m-1, j=n-1, k=n+m-1;
        while(i>=0 && j>=0)
            if(nums1[i] > nums2[j])
                nums1[k--] = nums1[i--];
            else
                nums1[k--] = nums2[j--];
        while(j>=0)
            nums1[k--] = nums2[j--];

114. Add two Binary Numbers:
	a. Take two iterators(i=m-1, j=n-1) from the end of two binary numbers and we have to go towards the front.
	b. Till we have either i, j or carry available, we keep iterating
	c. Add A[i], B[j] to carry if they are not exhausted yet.
	d. value would be carry & 1 and the upated value of carry would be carry >> 1
	e. Reverse the final outcome.
	f. ALGO:
		string res;
        int carry = 0, sum, i = A.size() - 1, j = B.size() - 1;
        while (i >= 0 || j >= 0 || carry) {
            sum=0;
            if (i >= 0) 
                 sum += A[i--]-'0';
            if (j >= 0) 
                 sum += B[j--]-'0';
            sum += carry;
            res += to_string(sum&1);
            carry = (sum >> 1);
        }
        reverse(res.begin(), res.end());
        return res;

115. Text Justification: TODO

116. Accounts Merge: Given name and array of emails, merge them.
	a. We create a graph of emails. Draw two edges between the two related emails, if they belong to the same person.
	b. We also try to keep track of each email to name map.
	c. Then we iterate over the graph of emails in a DFS way. We use a visited[emails] to prevent infinite loop.
	d. ALGO:
		unordered_map<string, vector<string>> graph;
	    unordered_map<string,string> email_to_name;
	    unordered_set<string> visited;
	    
	    
	    void dfs(string email, set<string> &email_set) {
	        if(visited.count(email))
	            return;
	        visited.insert(email);
	        email_set.insert(email);
	        for(auto email : graph[email])
	            dfs(email, email_set);
	    }

	    void buildGraph(vector<vector<string>>& accounts){
	        for(int i = 0; i < accounts.size(); ++i) {
	            string name = accounts[i][0];
	            string first_email = accounts[i][1];
	            
	            for(int j = 1; j < accounts[i].size(); ++j) {
	                string email = accounts[i][j];
	                graph[first_email].push_back(email);
	                graph[email].push_back(first_email);
	                if(!email_to_name.count(email))
	                    email_to_name[email] = name;
	            }
	        }
	    }

	    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
	        vector<vector<string>> res;
	        buildGraph(accounts);
	        
	        for(auto [email, _] : graph) {
	            if(!visited.count(email)) {
	                set<string> email_set; // due to this, the email list remain sorted (its a set)
	                dfs(email, email_set);
	                
	                vector<string> account(email_set.begin(), email_set.end());
	                string name = email_to_name[email];
	                account.insert(account.begin(), name);
	                res.push_back(account);
	            }
	        }
	        return res;
	    }

117. Longest String without aaa, bbb and ccc given some freq of a,b and c.
	a. Create a max heap of the form pair<int,char> to store the count of each character(a,b & c).
    b. while (pq.size()>1) Pop out the first 2 pair who have the max frequency.
    c. Add greedily the occurances of the first pair to the ans and update it's count.
    d. For the second pair, compare it's occurances with the first pair and add accordingly (either 1 or 2)
    e. Finally add the pairs back to the Max Heap if their count>0.
    f. If pq.empty() return ans, else add the leftover character 
        to the ans according to the remaining counts and return the ans.
    g. ALGO:
    	priority_queue<pair<int,char>>pq;
        if(a) pq.push({a,'a'});
        if(b) pq.push({b,'b'});
        if(c) pq.push({c,'c'});
        
        string ans="";
    
        while(pq.size()>1){
            pair<int,char>one = pq.top();pq.pop();
            pair<int,char>two = pq.top();pq.pop();

            if(one.first>=2){
                ans+=one.second; ans+=one.second;
                one.first-=2;
            }
            else{
                ans+=one.second;
                one.first-=1;
            }
            if(two.first>=2 && two.first>=one.first){
                ans+=two.second;
                ans+=two.second;
                two.first-=2;
            }
            else{
                ans+=two.second;
                two.first-=1;
            }
            if(one.first>0) pq.push(one);
            if(two.first>0) pq.push(two);
        }
        if(pq.empty())
            return ans;
        if(pq.top().first>=2){
            ans+=pq.top().second; ans+=pq.top().second;
        }
        else{
            ans+=pq.top().second;
        }
        return ans;
	
118. Power Set of an Array:
	a. Iterating over all the nums(i) and at each step one takes new integer into consideration 
		and generates new subsets from the existing ones in ans. Then push the new subset into the ans 
		so that the next integer can use it to form new subsets as well.
	b. Start with an empty set since it is always present in a power set.
	c. 	Arr: 1 2 3
		     [[]]
		 i:1 [[],[1]]
		 i:2 [[],[1],[2],[1,2]]
		 i:3 [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
	d. TC: O(Nx2^N)
	e. ALGO:
	    vector<vector<int>> ans;
	    ans.push_back({});
	    for(int i=0; i<nums.size(); i++){
	        vector<vector<int>> new_subsets;
	        for(int j=0; j<ans.size(); j++){
	            vector<int> x = ans[j];
	            x.push_back(nums[i]);
	            new_subsets.push_back(x);
	        }
	        for(auto subs: new_subsets)
	            ans.push_back(subs);
	    }
	    return ans;

119. Remove the minimum number of invalid parentheses to make the input string valid & return all possible results: Backtracking
	a. TODO

120. Flatten a multi-level doubly linked list:
	a. Keep track of prev and current. Prev is required so that we can return the last node of the LL for this level.
	b. When the current's child is NULL, this node is fine, move ahead.
	c. When the current's child is Not NULL, then we need to fix it and connect it to current's next.
	d. ALGO:
		Node* helper(Node* current){
		    Node *pre;
		    
		    while(current != NULL){
		        if(current->child == NULL){
		            pre = current;
		            current = current->next;
		        }

		        // If the child pointer is not null, we do:
		        // - connect child's prev to itself (current)
		        // - save the current's next because it will be lost when we connect current's next to current's child
		        // - current next will not point to the child
		        // - call the same function for the child node recursively so it does all this too. This should return the last node of the child's DLL
		        // - after child traversal is done, we make current's child to be NULL
		        // - the last node of the child must be connected to the saved_node's prev
		        // - update pre and move current looking for the next node
		        else{
		            current->child->prev = current;
		            Node* saved_next = current->next;
		            current->next = current->child;
		            Node* last_node = helper(current->child);
		            current->child = NULL;
		            last_node->next = saved_next;
		            if(saved_next)
		                saved_next->prev = last_node;
		            pre = current;
		            current = current->next;
		        }
		    }
		    return pre;
		}

121. Strobogrammatic Number is a number that looks the same when rotated 180 degrees. Check if the given num is a SN.
	a. Since 2,3,4,5,7 don't form any digit when rotated, simply return false if you see them.
	b. have a map of rotated numbers for the rest and use it when traversing the string.
	c. Form the rotated number and check if it is same. Return true/false.
	d. ALGO:
		string rotatedString="";
        unordered_map<char, char> map = {{'1','1'},{'0','0'},{'8','8'},{'6','9'},{'9','6'}};
        for(int i=0; i<nums.size(); i++){
            if(nums[i] == 2 || nums[i] == 3 || nums[i] == 4 || nums[i] == 5 || nums[i] == 7 )
                return false;
            rotatedString = map[nums[i]] + rotatedString;
        }
        return (rotatedString == nums);

122. Non-Overlapping Intervals: Given an array of intervals intervals return the min number of intervals you need to remove to make the rest of them non-overlapping.
	a. Sort the intervals on start time.
	b. There can be only 3 cases in a prev interval and the next interval
	    i. no overlap: we update the prev and nothing is removed
	    ii. total overlap: we choose the smaller one & remove the bigger one since the same area 
	        can accomodate more intervals now. We update prev and since we do not consider the other 
	        interval now, we update removedCount.
	    iii. partial overlap: we choose the prev over current and update the removeCount.
	c. TC: O(nlogn)
	d. ALGO:
		if(intervals.size() <= 1)
            return 0;
        
        sort(intervals.begin(), intervals.end());
        
        int n= intervals.size(), prev=0, removeCount=0;
        
        for(int i=1;i<intervals.size(); i++){
            if(intervals[prev][1] > intervals[i][0]){ 		// overlapping
                if(intervals[prev][1] > intervals[i][1]) 	// total overlap, move ahead & removeCount++
                    prev = i;   
                removeCount++;    							// partial overlap, only removeCount++; (no need to move ahead)
            }
            else 											// no overlap, just move ahead, no change remove count
                prev = i;
        }
        return removeCount;

123. Maximum Points by removing K cards from Front and Back: Sliding Window
	a. We must draw exactly k cards from the array in such a way that the score (sum of the cards) is maximized. 
		After drawing k cards from the array cardPoints.length - k cards will remain in the array.
	b. Another way that we could view the problem is that our objective is to choose cards from the beginning or end of
		array in such a way that the sum of the remaining cards is minimized.
	c. We can use a sliding window to find the subarray of size cardPoints.length - k that has the minimal sum. 
		Subtracting this value from the total sum of all the cards will give us our answer.
	d. TC: O(n), VERY SIMILAR TO MAXIMUM SUM OF ALL SUBARRAYS OF SIZE K (43)
	e. ALGO:
		for(auto e : cardPoints)
            totalScore+= e;
        if (k == n)
            return totalScore;
        int minSum = totalScore;
        
        for(int j=0; j<n; j++) {
            currentSum += cardPoints[j];
            int lengthOfWindow = j - i + 1;
            if(lengthOfWindow == n-k) {
                minSum = min(minSum, currentSum);
                currentSum -= cardPoints[i++];
            }
        }
        return totalScore-minSum;

124. Longest Repeating Character after K replacements: Sliding Window
	a. We iterate over the string like sliding window and for all possible substrings we check for the condition:
        (length of substring - freq of maximum occuring character in THIS substring) <= k 
    b. If this condition holds true, then we can replace the OTHER characters to max freq character to get the same character in the substring,
    c. Then, we increase the window by 1 size and check if this condition still holds true, if yes, then increase the max same character result.
    d. After some time, the condition will not hold true since the number of OTHER chars > k and then we cant replace all of them to max freq since they are > k
    	Then, we shorten the window from the start and keep checking if the cond. holds true now?
   	e. ALGO:
   		int i=0; // start of sliding window (i.. j-1)
        int j=0; // next char of the window
        int maxCharCount=0, result=0;
        unordered_map<char, int> freq;
        while(j!=s.size()){
            freq[s[j]]++;
            maxCharCount = max(maxCharCount, freq[s[j]]);
            while(j-i-maxCharCount+1 > k){
                freq[s[i]]--;
                i++;
                for(auto m: freq)
                    maxCharCount = max(maxCharCount, m.second);
            }
            result = max(result, j-i+1);
            j++;
        }
        return result;

125. Minimum Length Subarray with Sum >= Target (Only Positive Integers) Sliding Window
	a. Slide Window and keep checking the sum of all elements in the window with the length of window
    b. If at any point, we get the sum is lesser length, update it.
    c. Outer loop expands the window
    d. Inner loop shortens it till the condition sum>=target holds true
    e. ALGO:
        while(j!=nums.size()){
            sum += nums[j];
            currentLen++;
            while(sum >= target){
                minlen = min(minlen, currentLen);
                sum -= nums[i];
                currentLen--;
                i++;
            }
            j++;
        }
        return minlen == nums.size()+1 ? 0 : minlen;

126. FLAMES Game:
	a. Input both the names in set1, set2.
	b. Calculate Intersection of those sets => This will give us what is common in them
	c. Calculate Union of those sets => This will give us total unique elements.
	d. DiffSet = (UnionSet-Intersection) will give us the chars which are not CUT OFF since they were not common.
	e. Elements in this set's size % 6 can give us the wanted result.
	f. ALGO:
		for(int i=0;i<s1.size();i++)
			set1.insert(s1[i]);
		for(int i=0;i<s2.size();i++)
			set2.insert(s2[i]);

		set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), back_inserter(intersectionSet));
		set_union(set1.begin(), set1.end(), set2.begin(), set2.end(), back_inserter(unionSet));
		set_difference(unionSet.begin(), unionSet.end(), intersectionSet.begin(), intersectionSet.end(), back_inserter(diffSet));
		
		if(diffSet.size()%6 == 0)
			return flames_map[5];
		else
			return flames_map[diffSet.size()%6 - 1];

127. Longest Mountain in an array:
	a. Start with a base and check if you have a mountain ahead of you.
    b. To check for a mountain, you must travel upwards to reach a peak
    	while(end+1 < N && arr[end]<arr[end+1])
            end++;
    c. Then travel downwards.
    	while(end+1<N && arr[end]>arr[end+1])
            end++;
    d. The length of a montain would be (end-start+1)
    e. Get the largest mountain.
    f. ALGO:
    	while(base < N) {
            // Start end with the base and try to keep growing it
            end = base;
            
            // we do NOT want the flow to reach the next if loop of travelling 
            // down the mountain without travelling up so we need this condition
            if(end+1 < N && arr[end]<arr[end+1]){
                
                // travelling upwards to reach the peak of the mountain
                while(end+1 < N && arr[end]<arr[end+1])
                    end++;

                // we want to update the ans only when we have travelled to the 
                // end of the mountain, so we need this if condition check
                if(end+1<N && arr[end]>arr[end+1]) {
                    
                    // travelling downwards to reach the end of the mountain
                    while(end+1<N && arr[end]>arr[end+1])
                        end++;
                    
                    // Now we have reached the bottom of the mountain
                    // Check if this is the largest mountain we have?
                    ans = max(ans, end-base+1);
                }
            }
            
            // If there was a mountian, update base to the end of it.. to search for a new mountain
            // Otherwise increase base by 1 and check.
            base = max(end, base+1);
        }
        return ans;

128. Minimum Window Substring: Calculate the minimum length window in string s which has all the chars of string t.
	a. Save the freq of chars of t in a map1.
	b. Iterate over the string s with two pointers(i, j) like a sliding window till the latter reaches the end of string s.
	c. Have a map to store the characters which are present in the window between i and j.
	d. The number of characters required with correct freq in the window is map1.size() and we have 'formed' 0 out of them.
	e. We keep including the chars in window till we dont have formed==required. Then we shorten the window since we want min size window
	f. ALGO:
        if (s==t)
            return s;
        if(s.length() == 0  || t.length() == 0 || t.size()> s.size())
            return "";

        unordered_map<char, int> umap;
        for(int i=0; i<t.size(); i++)
            umap[t[i]]++;
        
        unordered_map<char, int> window;
        int required=umap.size(), formed=0, i=0, j=0;
        string ans;
        
        while(j<s.size()){
            window[s[j]]++;
            if(umap.count(s[j]) && umap[s[j]] == window[s[j]])
                formed++;
            
            while(i<=j && formed == required){
                if(ans.empty() || j-i+1 < ans.size())
                    ans = s.substr(i, j-i+1);
                window[s[i]]--;
                if(umap.count(s[j]) && window[s[i]] < umap[s[i]])
                    formed--;
                i++;
            }
            j++;
        }
        return ans;

129. Task Schedueler: TODO

130. Find K closest Elements to X in a sorted array. (X may not be there in the array): Binary Search
	a. Search for the element closest to X with lower_bound(). Set that as R. L=R-1
	b. We expand from these pointers on a condition x - arr[L] <= arr[R] - x
	c. ALGO:
        int n= arr.size();
        int R = lower_bound(arr.begin(), arr.end(), x) - arr.begin(); // LB returns an iterator but we need the index so iterator - begin() gives us the index
        int L =R-1;
        
        while(k--){
            if(R>=n || L>=0 && x-arr[L] <= arr[R]-x ) L--;
            else R++;
        }
        return vector(arr.begin()+L+1, arr.begin()+R); // L, R would remain just outside the window so taking L+1, R (since index starts from 0)

131. Word Search: Search for a word in a matrix of chars: Backtracking
	a. Iterate over all the elements checking if this is the starting of the word.
    b. If we find the start, we iterate on the rest of the board looking for more letters in the word
    c. If we are able to reach the end, return true. If we cant reach the end, then we backtrack.
    d. We use a visited array to keep check of where we have already travelled
    e. ALGO:
    	bool dfs(vector<vector<char>>&board, vector<vector<bool>>&visited, string word, int i, int j, int word_i ) {
	        int m = board.size();
	        int n = board[0].size();
	        if (i<0 || i>=m || j<0 || j>=n || visited[i][j] == true || board[i][j] != word[word_i])
	            return false;
	        
	        visited[i][j] = true;
	       	
	        if(word_i == word.size()-1)
	            return true;
	        else if (dfs(board, visited, word, i+1, j, word_i+1) || dfs(board, visited, word, i-1, j, word_i+1) || dfs(board, visited, word, i, j+1, word_i+1) || dfs(board, visited, word, i, j-1, word_i+1))
	            return true;

	        visited[i][j] = false;
	        return false;
	    }

    	for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                vector<bool> tmp(n, false);
                vector<vector<bool>> visited (m, tmp);
                if(dfs(board, visited, word, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;

132. Number of Islands: DFS/Union Find.
	a. Normal DFS
	b. UF: Use count integer which would first be the number of 1s but will decrease on each union of 2 ones. Return count finally.
	c. Check this file and look for the SIMILAR QUESTION 1 - NUMBER OF CONNECTED COMPONENTS OF A GRAPH which can 
		also be solved with a similar 'count' approach for UF.

133. Redundant Connection: One Extra edge is added in the graph which makes it cyclic. Return that edge whose removal will make it noncyclic: Union Find.
	a. Simple union find where UNION returns true/false if the nodes belong to same/different groups.
	b. While processing an edge, if UNION returns that they belong to same edge, then adding this edge will cause a cycle and we return it.

134. Making a Large Island by changing at most one 0 to 1 in a matrix: Union Find with parent, rank and size vectors.
	a. Create a UF from the matrix
	b. Iterate over the matrix and look for 0s, check if we convert it, then will we be joining different groups, if yes then add their sizes and return the max size.
	c. Note that a 1 on left and 1 on right may actually belong to the same group, then we should not add the size since they belong to the same group.

135. Largest Rectangle in a Histogram: Stack
	a. We take a stack and iterate over the heights array
	b. If we have an empty stack or increasing/equal value compared to stack top, just push the index in the stack and move on.
	c. If we have decreasing value at any point of time, we pop the elements from stack and keep calculating the area = arr[top]*(i-st.top()-1) and maxArea.
	d. If the iteration completes and we still have items remaining in the stack, we calculate their area till stack is empty.
	e. ALGO:
		int largestRectangleArea(vector<int>& arr) {
	        stack<int> st; // stack to store indexes
	        int area, maxArea = -1;
	        int i;
	        for(i=0; i<arr.size();){
	            if(st.empty() || arr[st.top()] <= arr[i] ){
	                st.push(i);
	                i++;
	            }
	            else {
	                int top = st.top();
	                st.pop();
	                if(st.empty())
	                    area = arr[top] * i;
	                else
	                    area = arr[top]* (i-st.top()-1);
	                maxArea = max(area, maxArea);
	            }
	        }
	        
	        while(!st.empty()) {
	            int top = st.top();
	            st.pop();
	            if(st.empty())
	                area = arr[top] * i;
	            else
	                area = arr[top]* (i-st.top()-1);
	            maxArea = max(area, maxArea);
	        }
	        
	        return maxArea;
	    }

136. Largest Rectangle in Matrix of 0s and 1s: Stack
	a. We just iterate row by row and try to create a histogram like thing in an array
    	- If the value is a 0, we make the height 0, if it is 1, we add it to the prior height
    b. At each point, we find the max Area of rectangle in histogram - in O(n) time.
    c. The max of all areas is the largest rectangle in the matrix.
    d. ALGO:
    	int maximalRectangle(vector<vector<char>>& matrix) {
	        if(matrix.size() == 0)
	            return 0;
	        int m = matrix.size(), n = matrix[0].size();
	        int area = 0, maxArea = 0;
	        vector<int> dp(n,0);

	        for(int i=0; i<m; i++){
	            for(int j=0; j<n; j++)
	                if (matrix[i][j] == '0')
	                    dp[j] = 0;
	                else
	                    dp[j] += 1;
	            area = maxAreaInHistogram(dp);
	            maxArea = max(area, maxArea);
	        }
	        return maxArea;
	    }

	a. SIMILAR: Largest Square in Matrix of 0s and 1s: DP
	b. First row and colm remain the same: dp[i][0] =  grid[i][0],  dp[0][i] = grid[0][i]
	c. For others, we check for the max sq we can make by checking dp[i-1][j], dp[i][j-1], dp[i-1][j-1]
	d. ALGO:
		for(int i=0;i<m; i++)
            for(int j=0;j<n;j++)
                if(i==0 || j==0)
                    dp[i][j] = matrix[i][j]-'0';
                else if(matrix[i][j] == '1'){
                    if(dp[i-1][j]!=0 && dp[i][j-1]!=0 && dp[i-1][j-1]!=0)
                        dp[i][j] = min(min(dp[i-1][j],dp[i-1][j-1]),dp[i][j-1])+1;
                    else
                        dp[i][j] = 1;

        int max = INT_MIN;
        for(int i=0;i<m; i++)
            for(int j=0;j<n;j++)
                    max = max(max, dp[i][j]);
        return max*max;

137. Top K Frequent Elements: Priority Queue
	a. Create a map of frequencies.
	b. Create a PQ with frequncy,elements.
	c. Pop out K frequent letters.
	d. ALGO:
		priority_queue<pair<int, int>> pq;
        unordered_map<int, int> freq;
        vector<int> ans;
        
        for(int i=0;i<nums.size(); i++)
            freq[nums[i]]++;
        
        for(auto k: freq)
            pq.push({k.second, k.first});
        
        while(k--){
            pair<int, int> front = pq.top();
            ans.push_back(front.second);
            pq.pop();
        }
        return ans;

138. For each element in the array, we have to find the distance with all the 1s in the array: Left to Right and RIght to Left Parsing
	a. For each element, calculate the number of 1s on its left and 1s on its right
	b. For each element, calculate the cost of 1s from the elements on its left & on its right
	c. Add the leftCost & rightCost for each i & that would be the final cost.
	d. Example:
        boxes      11010
        leftCount  01223 (How many 1s are to the left of your index)
        leftCost   01358 (What is the cost of 1s to the left of your index)
        rightCount 21100 (How many 1s are to the right of your index)
        rightCost  42100 (What is the cost of 1s to the right of your index)
        ans        43458 (Total cost of 1s to the left + right)
    e. ALGO:
    	for(int i=1; i<n; i++){
            if(boxes[i-1] == '1')
                leftCount[i] = leftCount[i-1]+1;
            else 
                leftCount[i] = leftCount[i-1];
            leftCost[i] = leftCost[i-1]+leftCount[i];
        }
        
        for(int i=n-2; i>=0; i--){
            if(boxes[i+1] == '1')
                rightCount[i] = rightCount[i+1]+1;
            else 
                rightCount[i] = rightCount[i+1];
            rightCost[i] = rightCost[i+1]+rightCount[i];
        }
        
        for(int i=0; i<n; i++){
            res.push_back(leftCost[i]+rightCost[i]);
        }
        
        return res;


139. Sort an array on the basis of the ordering given from a different array
	a. Create a map of frequencies of letters in arr1
	b. Iterate over arr2 and add the letters with their frequencies number of times in the result & erase them from map
	c. Iterate over the remaining map and add the letters with their freq num. of times in the result
	d. ALGO:
		map<int, int> map;
        vector<int> res;
        for(auto a: arr1)
            map[a]++;
        for(auto a: arr2){
            for(int i=0; i<map[a]; i++)
                res.push_back(a);
            map.erase(a);
        }
        for(auto a: map){
            for(int i=0; i<a.second; i++)
                res.push_back(a.first);
            map.erase(a.first);
        }
        return res;

140. Isomorphic Strings: Two strings s and t are isomorphic if the characters in s can be replaced to get t.
	a. We can map a character only to itself or to one other character.
	b. No two character should map to same character.
	c. Replacing each character in string s with the character it is mapped to results in string t.
	d. ALGO:
		vector<int> StoT(256, -1);
        vector<int> TtoS(256, -1);
        for(int i=0; i<s.size(); i++){
            // Case 1: No mapping exists in either of the dictionaries
            if(StoT[s[i]] == -1 && TtoS[t[i]] == -1){
                StoT[s[i]] = t[i];
                TtoS[t[i]] = s[i];
            }
            // Case 2: Either mapping doesn't exist in one of the dictionaries or Mapping exists and
            // it doesn't match in either of the dictionaries or both 
            else if (StoT[s[i]]!=t[i] || TtoS[t[i]]!=s[i]){
                return false;
            }
        }
        return true;
    e. NOTE:
    	We cant do it with 1 map because consider:
        s = "bad"
	    t = "bab"

	    "b" is mapped with "b", "a" is mapped with "a" and "d" is not mapped, so we map "d" with "b"
	    But this is wrong since no two chars can be mapped to same character. To keep track of what is 
	    mapped to, we will need another map and when that map says "This "b" is already mapped to, then 
	    it raises a red flag.

141. Kth Missing Positive Number in a sorted array: Binary Search
	a. The number of positive integers which are missing before the arr[idx] is equal to arr[idx] - idx - 1.
	b. Apply binary search to find the arr[i] after which Kth positive integer lie
	c. Then the Kth missing positive will be:
		arr[i] + k - (arr[i] - i - 1). Here var right is used instead of 'i', left = right+1
		arr[right] + k - (arr[right] - right - 1) = k + right + 1 = k+ left
	d. ALGO:
		int left =0, right = arr.size()-1;
        while(left <= right){
            int mid = left+(right-left)/2;
            if(arr[mid]-mid-1 < k){
                left = mid+1;
            }
            else{
                right = mid-1;
            }
        }
        return left + k;

142. Pow() function:
	a. ALGO:
		double fastPow(double x, long long  n){
        	if(n==0)
	            return 1.0;
	        double half = fastPow(x, n/2);
	        if(n%2 == 0)
	            return half*half;
	        else
	            return half*half*x;
	    }
	    
	    double myPow(double x, int n) {
	        long long N = n;
	        if (N < 0) {
	            x = 1 / x;
	            N = -N;
	        }
	        return fastPow(x, n);
	    }

143. Triangle Number: From an array how many numbers exists where a+b>c
	a. Brute force would be O(n3) of which a better version is there O(n2logn) but a smarter solution exists in O(n2)
	b. Choose i 'n' times and for each i, choose j n times, but k would move and stay there for all values of j. 
		k will be reinitialized only when i is incremented. so for each i, we have n js and for each i we have n ks, so O(n2)
	c. ALGO:
		int triangleNumber(vector<int>& nums) {
	        int count = 0;
	        int n = nums.size();
	        sort(nums.begin(), nums.end());
	        
	        for(int i=0; i<n-2; i++){
	            int k = i+2;
	            for(int j=i+1; j<n-1 && nums[i]!=0; j++){
	                while(k < n && nums[i] + nums[j] > nums[k])
	                    k++;
	                count += k-j-1;
	            }
	        }
	        return count;
	    }

144. Two Sum Variants: HashMap, Two Pointer

145. Playing with Bits: 
	a. Check if num is a pow of 2: (n&(n-1)) == 0
	b. Counting number of set bits:
		unsigned int count = 0;
        while(n){
            count += n&1;
            n = n>>1;
        }
        return count;

146. Three Sum / K Sum: HaspMap, Two Pointer

147. 